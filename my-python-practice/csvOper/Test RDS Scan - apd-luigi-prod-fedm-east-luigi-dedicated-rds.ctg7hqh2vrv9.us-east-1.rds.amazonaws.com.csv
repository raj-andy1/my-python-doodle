Plugin ID,CVE,CVSS v2.0 Base Score,Risk,Host,Protocol,Port,Name,Synopsis,Description,Solution,See Also,Plugin Output
"10287","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","udp","0","Traceroute Information","It was possible to obtain traceroute information.","Makes a traceroute to the remote host.","n/a","","For your information, here is the traceroute from 10.215.19.122 to 10.215.138.146 : 
10.215.19.122

ttl was greater than 50 - Completing Traceroute.

?

Hop Count: 1

An error was detected along the way.

"
"10863","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL Certificate Information","This plugin displays the SSL certificate.","This plugin connects to every SSL-related port and attempts to 
extract and dump the X.509 certificate.","n/a","","Subject Name: 

Common Name: apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com
Organization Unit: RDS
Organization: Amazon.com
Locality: Seattle
State/Province: Washington
Country: US

Issuer Name: 

Country: US
Organization: Amazon Web Services, Inc.
Organization Unit: Amazon RDS
State/Province: WA
Common Name: Amazon RDS us-east-1 Subordinate CA RSA2048 G1.A.7
Locality: Seattle

Serial Number: 34 74 7F 0E 7D E2 DD D9 94 34 07 FB BF 37 8A E8 

Version: 3

Signature Algorithm: SHA-256 With RSA Encryption

Not Valid Before: Jun 02 08:17:33 2024 GMT
Not Valid After: Jun 02 08:17:33 2025 GMT

Public Key Info: 

Algorithm: RSA Encryption
Key Length: 2048 bits
Public Key: 00 92 0D E1 32 1D 88 5E 40 74 8E F9 A1 0E F7 7B E0 AC E6 85 
            AA DA 66 1A 2D DC 8D 27 8E 8B 66 A4 FA CA 32 8E B0 E8 C9 DE 
            D0 CB D5 ED 16 A8 BD BF C2 FC 0C 32 3A BE 4A 3C E4 55 1C 1A 
            16 60 EA 47 76 06 45 8A 29 BB 2A 5A C9 EA 9A 44 C6 23 C4 FB 
            9A 98 10 DC AB AE 0E 43 A0 FC 84 6D 04 49 C3 95 83 84 B8 A0 
            65 AD 89 55 57 C0 9D 30 9A 71 1B 39 46 54 42 B0 02 09 62 BF 
            FC E2 87 CE 52 05 20 9A 17 E5 3E AD 38 6D B2 1C 2B 7E 97 65 
            95 56 85 D2 6D F6 A0 C5 A9 55 3C 6A 6B 3C 6E 4B 4E A6 0A 1D 
            5F 70 6B 85 93 D7 ED A1 52 68 BA E5 FB 78 E8 36 CB 16 59 83 
            C8 B8 CD CF 5D 2C D6 FC F8 B4 41 80 D6 54 36 5C 5A 0E 1A D0 
            E9 E9 84 A7 4E 38 04 08 53 66 94 F9 E4 8E 44 EC D6 36 07 3F 
            44 24 F7 B0 07 8E 98 E8 00 73 C3 3E 45 96 16 14 A6 1C D5 66 
            A4 3B 94 35 07 8F B1 4A C7 53 01 2B B0 15 18 1B D3 
Exponent: 01 00 01 

Signature Length: 256 bytes / 2048 bits
Signature: 00 47 65 49 03 4E 30 C0 C8 5A 61 07 E8 06 B1 32 49 FC 45 98 
           17 16 07 FE AE 09 B5 4E 85 7B 7B C3 E9 4C 3F 6F 16 D0 F6 0A 
           B5 7C 92 8A 75 05 B0 87 7D 98 F2 91 CC 48 A9 44 50 9B C9 EE 
           C6 D1 2D BF 7F 39 A7 41 AB AE 53 C2 BE 6C B3 25 26 42 5D 1D 
           EF 06 6A 6E 06 C8 79 30 C6 4F 75 E6 9E BA 1D D9 16 D9 B4 1B 
           5C FD 7C A4 A6 96 80 8E 6A EB A6 46 7A E7 D1 76 C6 05 49 40 
           18 78 33 A1 B0 D3 67 FA 8B 9A 07 58 A4 6A CE 20 4F 8F 26 41 
           7B 6B 57 52 B4 59 C2 FC CD 64 4E 0C D6 04 C9 BB 66 A5 79 FD 
           C4 D9 15 AA 6C C4 37 D0 2A 8E 26 2E 08 CC 76 D9 84 6F 3D DB 
           3E 17 35 73 89 4C 6F B9 C9 EC CD A4 59 73 41 E0 91 ED 3C CD 
           21 29 88 0C 27 58 F9 A3 68 74 3E 4A E9 3F 17 8C 9D 7C 15 DA 
           30 18 B5 BB 4A 1D F3 CF 62 FA BD DB 78 0F 79 7F C6 7C 4D 0C 
           C8 28 37 EE 69 B8 99 88 A8 C1 52 F8 C9 BB 22 A5 35 

Extension: Subject Alternative Name (2.5.29.17)
Critical: 0
DNS: apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com


Extension: Basic Constraints (2.5.29.19)
Critical: 0


Extension: Authority Key Identifier (2.5.29.35)
Critical: 0
Key Identifier: 17 14 D6 63 1E 85 51 4D FD 9A 8D E8 1A F6 85 AC F5 57 F1 19 


Extension: Subject Key Identifier (2.5.29.14)
Critical: 0
Subject Key Identifier: D5 C0 41 69 98 98 2E 65 73 9D 25 A7 7C 83 5D 76 21 AA 08 01 


Fingerprints : 

SHA-256 Fingerprint: DE B5 69 60 EE 0B B3 A0 88 03 06 1E 64 88 3F 54 2A AD A0 AD 
                     40 CC 28 26 F7 F3 B4 3D 54 D8 E1 35 
SHA-1 Fingerprint: CC 69 B7 20 21 A6 A1 36 57 FE 28 24 8B 29 00 38 03 39 DA FE 
MD5 Fingerprint: D2 B7 FE 18 A9 47 BE 3E 6D 0D 17 85 7C 49 87 55 


PEM certificate : 

-----BEGIN CERTIFICATE-----
MIIEljCCA36gAwIBAgIQNHR/Dn3i3dmUNAf7vzeK6DANBgkqhkiG9w0BAQsFADCBojELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTswOQYDVQQDDDJBbWF6b24gUkRTIHVzLWVhc3QtMSBTdWJvcmRpbmF0ZSBDQSBSU0EyMDQ4IEcxLkEuNzEQMA4GA1UEBwwHU2VhdHRsZTAeFw0yNDA2MDIwODE3MzNaFw0yNTA2MDIwODE3MzNaMIG3MV4wXAYDVQQDDFVhcGQtbHVpZ2ktcHJvZC1mZWRtLWVhc3QtbHVpZ2ktZGVkaWNhdGVkLXJkcy5jdGc3aHFoMnZydjkudXMtZWFzdC0xLnJkcy5hbWF6b25hd3MuY29tMQwwCgYDVQQLDANSRFMxEzARBgNVBAoMCkFtYXpvbi5jb20xEDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xCzAJBgNVBAYTAlVTMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkg3hMh2IXkB0jvmhDvd74KzmharaZhot3I0njotmpPrKMo6w6Mne0MvV7Raovb/C/AwyOr5KPORVHBoWYOpHdgZFiim7KlrJ6ppExiPE+5qYENyrrg5DoPyEbQRJw5WDhLigZa2JVVfAnTCacRs5RlRCsAIJYr/84ofOUgUgmhflPq04bbIcK36XZZVWhdJt9qDFqVU8ams8bktOpgodX3BrhZPX7aFSaLrl+3joNssWWYPIuM3PXSzW/Pi0QYDWVDZcWg4a0OnphKdOOAQIU2aU+eSOROzWNgc/RCT3sAeOmOgAc8M+RZYWFKYc1WakO5Q1B4+xSsdTASuwFRgb0wIDAQABo4GwMIGtMGAGA1UdEQRZMFeCVWFwZC1sdWlnaS1wcm9kLWZlZG0tZWFzdC1sdWlnaS1kZWRpY2F0ZWQtcmRzLmN0ZzdocWgydnJ2OS51cy1lYXN0LTEucmRzLmFtYXpvbmF3cy5jb20wCQYDVR0TBAIwADAfBgNVHSMEGDAWgBQXFNZjHoVRTf2ajega9oWs9VfxGTAdBgNVHQ4EFgQU1cBBaZiYLmVznSWnfINddiGqCAEwDQYJKoZIhvcNAQELBQADggEBAEdlSQNOMMDIWmEH6AaxMkn8RZgXFgf+rgm1ToV7e8PpTD9vFtD2CrV8kop1BbCHfZjykcxIqURQm8nuxtEtv385p0GrrlPCvmyzJSZCXR3vBmpuBsh5MMZPdeaeuh3ZFtm0G1z9fKSmloCOauumRnrn0XbGBUlAGHgzobDTZ/qLmgdYpGrOIE+PJkF7a1dStFnC/M1kTgzWBMm7ZqV5/cTZFapsxDfQKo4mLgjMdtmEbz3bPhc1c4lMb7nJ7M2kWXNB4JHtPM0hKYgMJ1j5o2h0PkrpPxeMnXwV2jAYtbtKHfPPYvq923gPeX/GfE0MyCg37mm4mYiowVL4ybsipTU=
-----END CERTIFICATE-----"
"12053","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","Host Fully Qualified Domain Name (FQDN) Resolution","It was possible to resolve the name of the remote host.","Nessus was able to resolve the fully qualified domain name (FQDN) of
the remote host.","n/a","","
10.215.138.146 resolves as ip-10-215-138-146.ec2.internal.
"
"19506","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","Nessus Scan Information","This plugin displays information about the Nessus scan.","This plugin displays, for each tested host, information about the
scan itself :

  - The version of the plugin set.
  - The type of scanner (Nessus or Nessus Home).
  - The version of the Nessus Engine.
  - The port scanner(s) used.
  - The port range scanned.
  - The ping round trip time 
  - Whether credentialed or third-party patch management
    checks are possible.
  - Whether the display of superseded patches is enabled
  - The date of the scan.
  - The duration of the scan.
  - The number of hosts scanned in parallel.
  - The number of checks done in parallel.","n/a","","Information about this scan : 

Nessus version : 10.7.4
Nessus build : 20055
Plugin feed version : 202406191741
Scanner edition used : Nessus
Scanner OS : LINUX
Scanner distribution : ubuntu1404-x86-64
Scan type : Normal
Scan name : Test RDS Scan - apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com
Scan policy used : Advanced Network Scan
Scanner IP : 10.215.19.122

WARNING : No port scanner was enabled during the scan. This may
lead to incomplete results.

Port range : default
Ping RTT : Unavailable
Thorough tests : no
Experimental tests : no
Scan for Unpatched Vulnerabilities : no
Plugin debugging enabled : no
Paranoia level : 1
Report verbosity : 1
Safe checks : yes
Optimize the test : no
Credentialed checks : no
Patch management checks : None
Display superseded patches : yes (supersedence plugin did not launch)
CGI scanning : disabled
Web application tests : disabled
Max hosts : 100
Max checks : 5
Recv timeout : 5
Backports : None
Allow post-scan editing : Yes
Nessus Plugin Signature Checking : Enabled
Audit File Signature Checking : Disabled
Scan Start Date : 2024/6/21 5:58 GMT
Scan duration : 1305 sec
Scan for malware : no
"
"21643","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL Cipher Suites Supported","The remote service encrypts communications using SSL.","This plugin detects which SSL ciphers are supported by the remote
service for encrypting communications.","n/a","https://www.openssl.org/docs/man1.0.2/man1/ciphers.html
http://www.nessus.org/u?e17ffced","
Here is the list of SSL ciphers supported by the remote server :
Each group is reported per SSL Version.

SSL Version : TLSv12
  High Strength Ciphers (>= 112-bit key)

    Name                          Code             KEX           Auth     Encryption             MAC
    ----------------------        ----------       ---           ----     ---------------------  ---
    DHE-RSA-AES128-SHA256         0x00, 0x9E       DH            RSA      AES-GCM(128)           SHA256
    DHE-RSA-AES256-SHA384         0x00, 0x9F       DH            RSA      AES-GCM(256)           SHA384
    ECDHE-RSA-AES128-SHA256       0xC0, 0x2F       ECDH          RSA      AES-GCM(128)           SHA256
    ECDHE-RSA-AES256-SHA384       0xC0, 0x30       ECDH          RSA      AES-GCM(256)           SHA384
    RSA-AES128-SHA256             0x00, 0x9C       RSA           RSA      AES-GCM(128)           SHA256
    RSA-AES256-SHA384             0x00, 0x9D       RSA           RSA      AES-GCM(256)           SHA384
    DHE-RSA-AES128-SHA            0x00, 0x33       DH            RSA      AES-CBC(128)           SHA1
    DHE-RSA-AES256-SHA            0x00, 0x39       DH            RSA      AES-CBC(256)           SHA1
    DHE-RSA-CAMELLIA128-SHA       0x00, 0x45       DH            RSA      Camellia-CBC(128)      SHA1
    DHE-RSA-CAMELLIA256-SHA       0x00, 0x88       DH            RSA      Camellia-CBC(256)      SHA1
    ECDHE-RSA-AES128-SHA          0xC0, 0x13       ECDH          RSA      AES-CBC(128)           SHA1
    ECDHE-RSA-AES256-SHA          0xC0, 0x14       ECDH          RSA      AES-CBC(256)           SHA1
    AES128-SHA                    0x00, 0x2F       RSA           RSA      AES-CBC(128)           SHA1
    AES256-SHA                    0x00, 0x35       RSA           RSA      AES-CBC(256)           SHA1
    CAMELLIA128-SHA               0x00, 0x41       RSA           RSA      Camellia-CBC(128)      SHA1
    CAMELLIA256-SHA               0x00, 0x84       RSA           RSA      Camellia-CBC(256)      SHA1
    DHE-RSA-AES128-SHA256         0x00, 0x67       DH            RSA      AES-CBC(128)           SHA256
    DHE-RSA-AES256-SHA256         0x00, 0x6B       DH            RSA      AES-CBC(256)           SHA256
    ECDHE-RSA-AES128-SHA256       0xC0, 0x27       ECDH          RSA      AES-CBC(128)           SHA256
    ECDHE-RSA-AES256-SHA384       0xC0, 0x28       ECDH          RSA      AES-CBC(256)           SHA384
    RSA-AES128-SHA256             0x00, 0x3C       RSA           RSA      AES-CBC(128)           SHA256
    RSA-AES256-SHA256             0x00, 0x3D       RSA           RSA      AES-CBC(256)           SHA256

The fields above are :

  {Tenable ciphername}
  {Cipher ID code}
  Kex={key exchange}
  Auth={authentication}
  Encrypt={symmetric encryption method}
  MAC={message authentication code}
  {export flag}

Note that this service does not encrypt traffic by default but does
support upgrading to an encrypted connection using STARTTLS.
"
"26024","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL Server Detection","A database service is listening on the remote host.","The remote service is a PostgreSQL database server, or a derivative
such as EnterpriseDB.","Limit incoming traffic to this port if desired.","https://www.postgresql.org/",""
"35297","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL Service Requests Client Certificate","The remote service requests an SSL client certificate.","The remote service encrypts communications using SSL/TLS, requests a
client certificate, and may require a valid certificate in order to
establish a connection to the underlying service.","n/a","","
A TLSv12 server is listening on this port that requests a client certificate.
"
"45590","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","Common Platform Enumeration (CPE)","It was possible to enumerate CPE names that matched on the remote
system.","By using information obtained from a Nessus scan, this plugin reports
CPE (Common Platform Enumeration) matches for various hardware and
software products found on a host. 

Note that if an official CPE is not available for the product, this
plugin computes the best possible CPE based on the information
available from the scan.","n/a","http://cpe.mitre.org/
https://nvd.nist.gov/products/cpe","
Following application CPE matched on the remote system : 

  cpe:/a:postgresql:postgresql:13.11 -> PostgreSQL
"
"51192","","6.4","Medium","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL Certificate Cannot Be Trusted","The SSL certificate for this service cannot be trusted.","The server's X.509 certificate cannot be trusted. This situation can
occur in three different ways, in which the chain of trust can be
broken, as stated below :

  - First, the top of the certificate chain sent by the
    server might not be descended from a known public
    certificate authority. This can occur either when the
    top of the chain is an unrecognized, self-signed
    certificate, or when intermediate certificates are
    missing that would connect the top of the certificate
    chain to a known public certificate authority.

  - Second, the certificate chain may contain a certificate
    that is not valid at the time of the scan. This can
    occur either when the scan occurs before one of the
    certificate's 'notBefore' dates, or after one of the
    certificate's 'notAfter' dates.

  - Third, the certificate chain may contain a signature
    that either didn't match the certificate's information
    or could not be verified. Bad signatures can be fixed by
    getting the certificate with the bad signature to be
    re-signed by its issuer. Signatures that could not be
    verified are the result of the certificate's issuer
    using a signing algorithm that Nessus either does not
    support or does not recognize.

If the remote host is a public host in production, any break in the
chain makes it more difficult for users to verify the authenticity and 
identity of the web server. This could make it easier to carry out 
man-in-the-middle attacks against the remote host.","Purchase or generate a proper SSL certificate for this service.","https://www.itu.int/rec/T-REC-X.509/en
https://en.wikipedia.org/wiki/X.509","
The following certificate was at the top of the certificate
chain sent by the remote host, but it is signed by an unknown
certificate authority :

|-Subject : C=US/O=Amazon Web Services, Inc./OU=Amazon RDS/ST=WA/CN=Amazon RDS us-east-1 Root CA RSA2048 G1/L=Seattle
|-Issuer  : C=US/O=Amazon Web Services, Inc./OU=Amazon RDS/ST=WA/CN=Amazon RDS us-east-1 Root CA RSA2048 G1/L=Seattle
"
"56984","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL / TLS Versions Supported","The remote service encrypts communications.","This plugin detects which SSL and TLS versions are supported by the
remote service for encrypting communications.","n/a","","
This port supports TLSv1.2.
"
"57041","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL Perfect Forward Secrecy Cipher Suites Supported","The remote service supports the use of SSL Perfect Forward Secrecy
ciphers, which maintain confidentiality even if the key is stolen.","The remote host supports the use of SSL ciphers that offer Perfect
Forward Secrecy (PFS) encryption.  These cipher suites ensure that
recorded SSL traffic cannot be broken at a future date if the server's
private key is compromised.","n/a","https://www.openssl.org/docs/manmaster/man1/ciphers.html
https://en.wikipedia.org/wiki/Diffie-Hellman_key_exchange
https://en.wikipedia.org/wiki/Perfect_forward_secrecy","
Here is the list of SSL PFS ciphers supported by the remote server :

  High Strength Ciphers (>= 112-bit key)

    Name                          Code             KEX           Auth     Encryption             MAC
    ----------------------        ----------       ---           ----     ---------------------  ---
    DHE-RSA-AES128-SHA256         0x00, 0x9E       DH            RSA      AES-GCM(128)           SHA256
    DHE-RSA-AES256-SHA384         0x00, 0x9F       DH            RSA      AES-GCM(256)           SHA384
    ECDHE-RSA-AES128-SHA256       0xC0, 0x2F       ECDH          RSA      AES-GCM(128)           SHA256
    ECDHE-RSA-AES256-SHA384       0xC0, 0x30       ECDH          RSA      AES-GCM(256)           SHA384
    DHE-RSA-AES128-SHA            0x00, 0x33       DH            RSA      AES-CBC(128)           SHA1
    DHE-RSA-AES256-SHA            0x00, 0x39       DH            RSA      AES-CBC(256)           SHA1
    DHE-RSA-CAMELLIA128-SHA       0x00, 0x45       DH            RSA      Camellia-CBC(128)      SHA1
    DHE-RSA-CAMELLIA256-SHA       0x00, 0x88       DH            RSA      Camellia-CBC(256)      SHA1
    ECDHE-RSA-AES128-SHA          0xC0, 0x13       ECDH          RSA      AES-CBC(128)           SHA1
    ECDHE-RSA-AES256-SHA          0xC0, 0x14       ECDH          RSA      AES-CBC(256)           SHA1
    DHE-RSA-AES128-SHA256         0x00, 0x67       DH            RSA      AES-CBC(128)           SHA256
    DHE-RSA-AES256-SHA256         0x00, 0x6B       DH            RSA      AES-CBC(256)           SHA256
    ECDHE-RSA-AES128-SHA256       0xC0, 0x27       ECDH          RSA      AES-CBC(128)           SHA256
    ECDHE-RSA-AES256-SHA384       0xC0, 0x28       ECDH          RSA      AES-CBC(256)           SHA384

The fields above are :

  {Tenable ciphername}
  {Cipher ID code}
  Kex={key exchange}
  Auth={authentication}
  Encrypt={symmetric encryption method}
  MAC={message authentication code}
  {export flag}
"
"57582","","6.4","Medium","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL Self-Signed Certificate","The SSL certificate chain for this service ends in an unrecognized
self-signed certificate.","The X.509 certificate chain for this service is not signed by a
recognized certificate authority.  If the remote host is a public host
in production, this nullifies the use of SSL as anyone could establish
a man-in-the-middle attack against the remote host. 

Note that this plugin does not check for certificate chains that end
in a certificate that is not self-signed, but is signed by an
unrecognized certificate authority.","Purchase or generate a proper SSL certificate for this service.","","
The following certificate was found at the top of the certificate
chain sent by the remote host, but is self-signed and was not
found in the list of known certificate authorities :

|-Subject : C=US/O=Amazon Web Services, Inc./OU=Amazon RDS/ST=WA/CN=Amazon RDS us-east-1 Root CA RSA2048 G1/L=Seattle
"
"63346","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL Version Detection","It was possible to gather database version information with the
supplied credentials.","It was possible to query the remote PostgreSQL database to determine
the version number with the supplied credentials.","n/a","","
  Source        : PostgreSQL 13.11 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 7.3.1 20180712 (Red Hat 7.3.1-12), 64-bit
  Version       : 13.11
  Database name : template1
"
"66334","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","Patch Report","The remote host is missing several patches.","The remote host is missing one or more security patches. This plugin lists the newest version of each patch to install 
to make sure the remote host is up-to-date.

Note: Because the 'Show missing patches that have been superseded' setting in your scan policy depends on this plugin,
it will always run and cannot be disabled.","Install the patches listed below.","","

. You need to take the following action :

[ PostgreSQL 12.x < 12.18 / 13.x < 13.14 / 14.x < 14.11 / 15.x < 15.6 SQL Injection (190512) ]

+ Action to take : Upgrade to PostgreSQL 12.18 / 13.14 / 14.11 / 15.6 or later

+Impact : Taking this action will resolve 5 different vulnerabilities (CVEs).



"
"70544","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL Cipher Block Chaining Cipher Suites Supported","The remote service supports the use of SSL Cipher Block Chaining
ciphers, which combine previous blocks with subsequent ones.","The remote host supports the use of SSL ciphers that operate in Cipher
Block Chaining (CBC) mode.  These cipher suites offer additional
security over Electronic Codebook (ECB) mode, but have the potential to
leak information if used improperly.","n/a","https://www.openssl.org/docs/manmaster/man1/ciphers.html
http://www.nessus.org/u?cc4a822a
https://www.openssl.org/~bodo/tls-cbc.txt","
Here is the list of SSL CBC ciphers supported by the remote server :

  High Strength Ciphers (>= 112-bit key)

    Name                          Code             KEX           Auth     Encryption             MAC
    ----------------------        ----------       ---           ----     ---------------------  ---
    DHE-RSA-AES128-SHA            0x00, 0x33       DH            RSA      AES-CBC(128)           SHA1
    DHE-RSA-AES256-SHA            0x00, 0x39       DH            RSA      AES-CBC(256)           SHA1
    DHE-RSA-CAMELLIA128-SHA       0x00, 0x45       DH            RSA      Camellia-CBC(128)      SHA1
    DHE-RSA-CAMELLIA256-SHA       0x00, 0x88       DH            RSA      Camellia-CBC(256)      SHA1
    ECDHE-RSA-AES128-SHA          0xC0, 0x13       ECDH          RSA      AES-CBC(128)           SHA1
    ECDHE-RSA-AES256-SHA          0xC0, 0x14       ECDH          RSA      AES-CBC(256)           SHA1
    AES128-SHA                    0x00, 0x2F       RSA           RSA      AES-CBC(128)           SHA1
    AES256-SHA                    0x00, 0x35       RSA           RSA      AES-CBC(256)           SHA1
    CAMELLIA128-SHA               0x00, 0x41       RSA           RSA      Camellia-CBC(128)      SHA1
    CAMELLIA256-SHA               0x00, 0x84       RSA           RSA      Camellia-CBC(256)      SHA1
    DHE-RSA-AES128-SHA256         0x00, 0x67       DH            RSA      AES-CBC(128)           SHA256
    DHE-RSA-AES256-SHA256         0x00, 0x6B       DH            RSA      AES-CBC(256)           SHA256
    ECDHE-RSA-AES128-SHA256       0xC0, 0x27       ECDH          RSA      AES-CBC(128)           SHA256
    ECDHE-RSA-AES256-SHA384       0xC0, 0x28       ECDH          RSA      AES-CBC(256)           SHA384
    RSA-AES128-SHA256             0x00, 0x3C       RSA           RSA      AES-CBC(128)           SHA256
    RSA-AES256-SHA256             0x00, 0x3D       RSA           RSA      AES-CBC(256)           SHA256

The fields above are :

  {Tenable ciphername}
  {Cipher ID code}
  Kex={key exchange}
  Auth={authentication}
  Encrypt={symmetric encryption method}
  MAC={message authentication code}
  {export flag}
"
"91826","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL Server Login Possible","It was possible to log into the remote database.","Nessus was able to log into the remote PostgreSQL server using the
supplied credentials.","n/a","https://www.postgresql.org/","Credentialed checks have been enabled for PostgreSQL server on port 5432."
"94761","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL Root Certification Authority Certificate Information","A root Certification Authority certificate was found at the top of the
certificate chain.","The remote service uses an SSL certificate chain that contains a
self-signed root Certification Authority certificate at the top of the
chain.","Ensure that use of this root Certification Authority certificate
complies with your organization's acceptable use and security
policies.","https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc778623(v=ws.10)","
The following root Certification Authority certificate was found :

|-Subject             : C=US/O=Amazon Web Services, Inc./OU=Amazon RDS/ST=WA/CN=Amazon RDS us-east-1 Root CA RSA2048 G1/L=Seattle
|-Issuer              : C=US/O=Amazon Web Services, Inc./OU=Amazon RDS/ST=WA/CN=Amazon RDS us-east-1 Root CA RSA2048 G1/L=Seattle
|-Valid From          : May 25 22:34:57 2021 GMT
|-Valid To            : May 25 23:34:57 2061 GMT
|-Signature Algorithm : SHA-256 With RSA Encryption
"
"118224","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL STARTTLS Support","The remote service supports encrypting traffic.","The remote PostgreSQL server supports the use of encryption
initiated during pre-login to switch from a cleartext to an
encrypted communications channel.","n/a","https://www.postgresql.org/docs/9.2/protocol-flow.html#AEN96066
https://www.postgresql.org/docs/9.2/protocol-message-formats.html","
The remote service responded to the pre-login packet in a way that
suggests that it supports encryption. However, Nessus failed to
negotiate a TLS connection or get the associated SSL certificate,
perhaps because of a network connectivity problem or the service
requires a peer certificate as part of the negotiation.
"
"136318","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","TLS Version 1.2 Protocol Detection","The remote service encrypts traffic using a version of TLS.","The remote service accepts connections encrypted using TLS 1.2.","N/A","https://tools.ietf.org/html/rfc5246","TLSv1.2 is enabled and the server supports at least one cipher."
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/luigi-luigi:
  ERROR: unable to login: [M: permission denied for database ""luigi-luigi""]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""CIS_PostgreSQL_13_v1.1.0_L1_DB.audit from CIS PostgreSQL 13 Benchmark v1.1.0"" : [WARNING]

NOTE: Nessus has not identified that the chosen audit applies to the target device.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Policy Value:
WARNING

Actual Value:
5432/luigi-luigi:
WARNING","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/luigi-luigi:
  ERROR: unable to login: [M: permission denied for database ""luigi-luigi""]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/luigi-luigi:
  ERROR: unable to login: [M: permission denied for database ""luigi-luigi""]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/rdsadmin:
  ERROR: unable to login: [M: pg_hba.conf rejects connection for host ""10.215.19.122"", user ""security_scanner"", database ""rdsadmin"", SSL on]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""CIS_PostgreSQL_13_v1.1.0_L1_DB.audit from CIS PostgreSQL 13 Benchmark v1.1.0"" : [WARNING]

NOTE: Nessus has not identified that the chosen audit applies to the target device.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Policy Value:
WARNING

Actual Value:
5432/rdsadmin:
WARNING","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/rdsadmin:
  ERROR: unable to login: [M: pg_hba.conf rejects connection for host ""10.215.19.122"", user ""security_scanner"", database ""rdsadmin"", SSL on]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/rdsadmin:
  ERROR: unable to login: [M: pg_hba.conf rejects connection for host ""10.215.19.122"", user ""security_scanner"", database ""rdsadmin"", SSL on]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""CIS_PostgreSQL_13_v1.1.0_L1_DB.audit from CIS PostgreSQL 13 Benchmark v1.1.0"" : [PASSED]

See Also: https://workbench.cisecurity.org/benchmarks/11864

Policy Value:
PASSED

Actual Value:
5432/postgres:
PASSED","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.2 Ensure the log destinations are set correctly"" : [PASSED]

PostgreSQL supports several methods for logging server messages, including stderr, csvlog, syslog, and jsonlog. On Windows, eventlog is also supported. One or more of these destinations should be set for server log output.

Rationale:

If log_destination is not set, then any log messages generated by the core PostgreSQL processes will be lost.

Solution:
Execute the following SQL statements to remediate this setting (in this example, setting the log destination to csvlog):

postgres=# alter system set log_destination = 'csvlog';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Note: If more than one log destination is to be used, set this parameter to a list of desired log destinations separated by commas (e.g. 'csvlog, stderr').

Default Value:

stderr

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_destination
sql_expect: STRING - stderr

Actual Value:
5432/postgres:
* [""stderr""]","Execute the following SQL statements to remediate this setting (in this example, setting the log destination to csvlog):

postgres=# alter system set log_destination = 'csvlog';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Note: If more than one log destination is to be used, set this parameter to a list of desired log destinations separated by commas (e.g. 'csvlog, stderr').

Default Value:

stderr","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.3 Ensure the logging collector is enabled"" : [PASSED]

The logging collector is a background process that captures log messages sent to stderr and redirects them into log files. The logging_collector setting must be enabled in order for this process to run. It can only be set at the server start.

Rationale:

The logging collector approach is often more useful than logging to syslog, since some types of messages might not appear in syslog output. One common example is dynamic-linker failure message; another may be error messages produced by scripts such as archive_command.

Note: This setting must be enabled when log_destination is either stderr or csvlog or logs will be lost. Certain other logging parameters require it as well.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set logging_collector = 'on';
ALTER SYSTEM

Unfortunately, this setting can only be changed at the server (re)start. As root, restart the PostgreSQL service for this change to take effect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since <date>; <count>s ago

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show logging_collector
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""on""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set logging_collector = 'on';
ALTER SYSTEM

Unfortunately, this setting can only be changed at the server (re)start. As root, restart the PostgreSQL service for this change to take effect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since <date>; <count>s ago

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.4 Ensure the log file destination directory is set correctly"" : [PASSED]

The log_directory setting specifies the destination directory for log files when log_destination is stderr or csvlog. It can be specified as relative to the cluster data directory ($PGDATA) or as an absolute path. log_directory should be set according to your organization's logging policy.

Rationale:

If log_directory is not set, it is interpreted as the absolute path '/' and PostgreSQL will attempt to write its logs there (and typically fail due to a lack of permissions to that directory). This parameter should be set to direct the logs into the appropriate directory location as defined by your organization's logging policy.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_directory='/var/log/postgres';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_directory;
 log_directory
---------------
 /var/log/postgres
(1 row)

Note: The use of /var/log/postgres, above, is an example. This should be set to an appropriate path as defined by your organization's logging requirements. Having said that, it is a good idea to have the logs outside of your PGDATA directory so that they are not included by things like pg_basebackup or pgBackRest.

Default Value:

log which is relative to the cluster's data directory (e.g. /var/lib/pgsql/<pgmajorversion>/data/log)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_directory
sql_expect: STRING - /rdsdbdata/log/error

Actual Value:
5432/postgres:
* [""/rdsdbdata/log/error""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_directory='/var/log/postgres';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_directory;
 log_directory
---------------
 /var/log/postgres
(1 row)

Note: The use of /var/log/postgres, above, is an example. This should be set to an appropriate path as defined by your organization's logging requirements. Having said that, it is a good idea to have the logs outside of your PGDATA directory so that they are not included by things like pg_basebackup or pgBackRest.

Default Value:

log which is relative to the cluster's data directory (e.g. /var/lib/pgsql/<pgmajorversion>/data/log)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.5 Ensure the filename pattern for log files is set correctly"" : [PASSED]

The log_filename setting specifies the filename pattern for log files. The value for log_filename should match your organization's logging policy.

The value is treated as a strftime pattern, so %-escapes can be used to specify time-varying file names. The supported %-escapes are similar to those listed in the Open Group's strftime specification. If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the partition that contains log_directory. If there are any time-zone-dependent %-escapes, the computation is done in the zone specified by log_timezone. Also, the system's strftime is not used directly, so platform-specific (nonstandard) extensions do not work.

If CSV-format output is enabled in log_destination, .csv will be appended to the log filename. (If log_filename ends in .log, the suffix is replaced instead.)

Rationale:

If log_filename is not set, then the value of log_directory is appended to an empty string and PostgreSQL will fail to start as it will try to write to a directory instead of a file.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_filename='postgresql-%Y%m%d.log';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_filename;
   log_filename
-------------------
 postgresql-%Y%m%d.log
(1 row)

Note: In this example, a new log file will be created for each day (e.g. postgresql-20200804.log)

Default Value:

The default is postgresql-%a.log, which creates a new log file for each day of the week (e.g. postgresql-Mon.log, postgresql-Tue.log).

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_filename
sql_expect: STRING - postgresql.log.%Y-%m-%d-%H

Actual Value:
5432/postgres:
* [""postgresql.log.%Y-%m-%d-%H""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_filename='postgresql-%Y%m%d.log';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_filename;
   log_filename
-------------------
 postgresql-%Y%m%d.log
(1 row)

Note: In this example, a new log file will be created for each day (e.g. postgresql-20200804.log)

Default Value:

The default is postgresql-%a.log, which creates a new log file for each day of the week (e.g. postgresql-Mon.log, postgresql-Tue.log).","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.6 Ensure the log file permissions are set correctly"" : [FAILED]

The log_file_mode setting determines the file permissions for log files when logging_collector is enabled. The parameter value is expected to be a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format, the number must start with a 0 (zero).)

The permissions should be set to allow only the necessary access to authorized personnel. In most cases, the best setting is 0600, so that only the server owner can read or write the log files. The other commonly useful setting is 0640, allowing members of the owner's group to read the files, although to make use of that, you will need to either alter the log_directory setting to store the log files outside the cluster data directory or use PGSETUP_INITDB_OPTIONS='-k -g' when initializing the cluster.

Rationale:

Log files often contain sensitive data. Allowing unnecessary access to log files may inadvertently expose sensitive data to unauthorized personnel.

Solution:
Execute the following SQL statement(s) to remediate this setting (with the example assuming the desired value of 0600):

postgres=# alter system set log_file_mode = '0600';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_file_mode;
 log_file_mode
---------------
 0600
(1 row)

Default Value:

0600

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
SQL_POLICY
sql_request: show log_file_mode
sql_expect: STRING - 0600

Actual Value:
5432/postgres:
  [""0644""]","Execute the following SQL statement(s) to remediate this setting (with the example assuming the desired value of 0600):

postgres=# alter system set log_file_mode = '0600';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_file_mode;
 log_file_mode
---------------
 0600
(1 row)

Default Value:

0600","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.7 Ensure 'log_truncate_on_rotation' is enabled"" : [FAILED]

Enabling the log_truncate_on_rotation setting when logging_collector is enabled causes PostgreSQL to truncate (overwrite) existing log files with the same name during log rotation instead of appending to them. For example, using this setting in combination with a log_filename setting value like postgresql-%H.log would result in generating 24 hourly log files and then cyclically overwriting them:

postgresql-00.log

postgresql-01.log

[...]

postgresql-23.log

Note: Truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation (see later in this benchmark for size-based rotation details).

Rationale:

If this setting is disabled, pre-existing log files will be appended to if log_filename is configured in such a way that static or recurring names are generated.

Enabling or disabling the truncation should only be decided when also considering the value of log_filename and log_rotation_age/log_rotation_size. Some examples to illustrate the interaction between these settings:

# truncation is moot, as each rotation gets a unique filename (postgresql-20180605.log)

log_truncate_on_rotation = on

log_filename = 'postgresql-%Y%m%d.log'

log_rotation_age = '1d'

log_rotation_size = 0

# truncation every hour, losing log data every hour until the date changes

log_truncate_on_rotation = on

log_filename = 'postgresql-%Y%m%d.log'

log_rotation_age = '1h'

log_rotation_size = 0

# no truncation if the date changed before generating 100M of log data, truncation otherwise

log_truncate_on_rotation = on

log_filename = 'postgresql-%Y%m%d.log'

log_rotation_age = '0'

log_rotation_size = '100M'

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_truncate_on_rotation = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_truncate_on_rotation;
 log_truncate_on_rotation
--------------------------
 on
(1 row)

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_truncate_on_rotation
sql_expect: STRING - on

Actual Value:
5432/postgres:
  [""off""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_truncate_on_rotation = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_truncate_on_rotation;
 log_truncate_on_rotation
--------------------------
 on
(1 row)

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.8 Ensure the maximum log file lifetime is set correctly"" : [PASSED]

When logging_collector is enabled, the log_rotation_age parameter determines the maximum lifetime of an individual log file (depending on the value of log_filename). After this many minutes have elapsed, a new log file will be created via automatic log file rotation. Current best practices advise log rotation at least daily, but your organization's logging policy should dictate your rotation schedule.

Rationale:

Log rotation is a standard best practice for log management.

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, setting it to one hour):

postgres=# alter system set log_rotation_age='1h';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

1d (one day)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_rotation_age
sql_expect: STRING - 1h

Actual Value:
5432/postgres:
* [""1h""]","Execute the following SQL statement(s) to remediate this setting (in this example, setting it to one hour):

postgres=# alter system set log_rotation_age='1h';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

1d (one day)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.9 Ensure the maximum log file size is set correctly"" : [PASSED]

The log_rotation_size setting determines the maximum size of an individual log file. Once the maximum size is reached, automatic log file rotation will occur.

Rationale:

If this is set to zero, the size-triggered creation of new log files is disabled. This will prevent automatic log file rotation when files become too large, which could put log data at increased risk of loss (unless age-based rotation is configured).

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, setting it to 1GB):

postgres=# alter system set log_rotation_size = '1GB';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

0

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_rotation_size
sql_expect: STRING - 10MB

Actual Value:
5432/postgres:
* [""10MB""]","Execute the following SQL statement(s) to remediate this setting (in this example, setting it to 1GB):

postgres=# alter system set log_rotation_size = '1GB';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

0","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.10 Ensure the correct syslog facility is selected"" : [PASSED]

The syslog_facility setting specifies the syslog 'facility' to be used when logging to syslog is enabled. You can choose from any of the 'local' facilities:

LOCAL0

LOCAL1

LOCAL2

LOCAL3

LOCAL4

LOCAL5

LOCAL6

LOCAL7

Your organization's logging policy should dictate which facility to use based on the syslog daemon in use.

Rationale:

If not set to the appropriate facility, the PostgreSQL log messages may be intermingled with other applications' log messages, incorrectly routed, or potentially dropped (depending on your syslog configuration).

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, setting it to the LOCAL1 facility):

postgres=# alter system set syslog_facility = 'LOCAL1';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

LOCAL0

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1M,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show syslog_facility
sql_expect: STRING - local0

Actual Value:
5432/postgres:
* [""local0""]","Execute the following SQL statement(s) to remediate this setting (in this example, setting it to the LOCAL1 facility):

postgres=# alter system set syslog_facility = 'LOCAL1';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

LOCAL0","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.11 Ensure syslog messages are not suppressed"" : [PASSED]

When logging to Syslog and syslog_sequence_numbers is on, then each message will be prefixed by an increasing sequence number (such as [2]).

Rationale:

Many modern Syslog implementations perform a log optimization and suppress repeated log entries while emitting '--- last message repeated N times ---'. In more modern Syslog implementations, repeated message suppression can be configured (for example, $RepeatedMsgReduction in rsyslog).

Impact:

If disabled, messages sent to Syslog could be suppressed and not logged. While a message is emitted stating that a given message was repeated and suppressed, the timestamp associated with these suppressed messages is lost, potentially damaging the recreation of an incident timeline.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set syslog_sequence_numbers = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show syslog_sequence_numbers
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""on""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set syslog_sequence_numbers = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.12 Ensure syslog messages are not lost due to size"" : [PASSED]

PostgreSQL log messages can exceed 1024 bytes, which is a typical size limit for traditional Syslog implementations. When syslog_split_messages is off, PostgreSQL server log messages are delivered to the Syslog service as is, and it is up to the Syslog service to cope with the potentially bulky messages. When syslog_split_messages is on, messages are split by lines, and long lines are split so that they will fit into 1024 bytes.

If syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.

Rationale:

Impact:

Depending on the Syslog server in use, log messages exceeding 1024 bytes may be lost or, potentially, cause the Syslog server processes to abort.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set syslog_split_messages = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show syslog_split_messages
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""on""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set syslog_split_messages = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.13 Ensure the program name for PostgreSQL syslog messages is correct"" : [PASSED]

The syslog_ident setting specifies the program name used to identify PostgreSQL messages in syslog logs. An example of a possible program name is postgres.

Rationale:

If this is not set correctly, it may be difficult or impossible to distinguish PostgreSQL messages from other messages in Syslog logs.

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, assuming a program name of proddb):

postgres=# alter system set syslog_ident = 'proddb';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show syslog_ident;
 syslog_ident
--------------
 proddb
(1 row)

Default Value:

postgres

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show syslog_ident
sql_expect: STRING - postgres

Actual Value:
5432/postgres:
* [""postgres""]","Execute the following SQL statement(s) to remediate this setting (in this example, assuming a program name of proddb):

postgres=# alter system set syslog_ident = 'proddb';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show syslog_ident;
 syslog_ident
--------------
 proddb
(1 row)

Default Value:

postgres","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.14 Ensure the correct messages are written to the server log"" : [PASSED]

The log_min_messages setting specifies the message levels that are written to the server log. Each level includes all the levels that follow it. The lower the level (vertically, below), the fewer messages are logged.

Valid values are:

DEBUG5 <-- exceedingly chatty

DEBUG4

DEBUG3

DEBUG2

DEBUG1

INFO

NOTICE

WARNING <-- default

ERROR

LOG

FATAL

PANIC <-- practically mute

WARNING is considered the best practice unless indicated otherwise by your organization's logging policy.

Rationale:

If this is not set to the correct value, too many or too few messages may be written to the server log.

Solution:
Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to set it to warning):

postgres=# alter system set log_min_messages = 'warning';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

WARNING

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_min_messages
sql_expect: STRING - warning

Actual Value:
5432/postgres:
* [""warning""]","Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to set it to warning):

postgres=# alter system set log_min_messages = 'warning';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

WARNING","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.15 Ensure the correct SQL statements generating errors are recorded"" : [PASSED]

The log_min_error_statement setting causes all SQL statements generating errors at or above the specified severity level to be recorded in the server log. Each level includes all the levels that follow it. The lower the level (vertically, below), the fewer messages are recorded. Valid values are:

DEBUG5 <-- exceedingly chatty

DEBUG4

DEBUG3

DEBUG2

DEBUG1

INFO

NOTICE

WARNING

ERROR <-- default

LOG

FATAL

PANIC <-- practically mute

ERROR is considered the best practice setting. Changes should only be made in accordance with your organization's logging policy.

Note: To effectively turn off logging of failing statements, set this parameter to PANIC.

Rationale:

If this is not set to the correct value, too many erring or too few erring SQL statements may be written to the server log.

Solution:
Execute the following SQL statement(s) as superuser to remediate this setting (in the example, to error):

postgres=# alter system set log_min_error_statement = 'error';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

ERROR

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_min_error_statement
sql_expect: STRING - error

Actual Value:
5432/postgres:
* [""error""]","Execute the following SQL statement(s) as superuser to remediate this setting (in the example, to error):

postgres=# alter system set log_min_error_statement = 'error';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

ERROR","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.16 Ensure 'debug_print_parse' is disabled - debug_print_parse is disabled"" : [PASSED]

The debug_print_parse setting enables printing the resulting parse tree for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.

Rationale:

Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set debug_print_parse='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: show debug_print_parse
sql_expect: STRING - off

Actual Value:
5432/postgres:
* [""off""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set debug_print_parse='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.17 Ensure 'debug_print_rewritten' is disabled - debug_print_rewritten is disabled"" : [PASSED]

The debug_print_rewritten setting enables printing the query rewriter output for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.

Rationale:

Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.

Solution:
Execute the following SQL statement(s) to disable this setting:

postgres=# alter system set debug_print_rewritten = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: show debug_print_rewritten
sql_expect: STRING - off

Actual Value:
5432/postgres:
* [""off""]","Execute the following SQL statement(s) to disable this setting:

postgres=# alter system set debug_print_rewritten = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.18 Ensure 'debug_print_plan' is disabled - debug_print_plan is disabled"" : [PASSED]

The debug_print_plan setting enables printing the execution plan for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.

Rationale:

Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.

Solution:
Execute the following SQL statement(s) to disable this setting:

postgres=# alter system set debug_print_plan = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: show debug_print_plan
sql_expect: STRING - off

Actual Value:
5432/postgres:
* [""off""]","Execute the following SQL statement(s) to disable this setting:

postgres=# alter system set debug_print_plan = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.19 Ensure 'debug_pretty_print' is enabled - debug_pretty_print is enabled"" : [PASSED]

Enabling debug_pretty_print indents the messages produced by debug_print_parse, debug_print_rewritten, or debug_print_plan making them significantly easier to read.

Rationale:

If this setting is disabled, the 'compact' format is used instead, significantly reducing the readability of the DEBUG statement log messages.

Impact:

Be advised that the aforementioned DEBUG printing options are disabled, but if your organizational logging policy requires them to be on then this option comes into play.

Solution:
Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set debug_pretty_print = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show debug_pretty_print
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""on""]","Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set debug_pretty_print = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.20 Ensure 'log_connections' is enabled - log_connections is enabled"" : [PASSED]

Enabling the log_connections setting causes each attempted connection to the server to be logged, as well as successful completion of client authentication. This parameter cannot be changed after the session start.

Rationale:

PostgreSQL does not maintain an internal record of attempted connections to the database for later auditing. It is only by enabling the logging of these attempts that one can determine if unexpected attempts are being made.

Note that enabling this without also enabling log_disconnections provides little value. Generally, you would enable/disable the pair together.

Solution:
Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set log_connections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Then, in a new connection to the database, verify the change:

postgres=# show log_connections;
 log_connections
-----------------
 on
(1 row)

Note that you cannot verify this change in the same connection in which it was changed; a new connection is needed.

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_connections
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""on""]","Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set log_connections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Then, in a new connection to the database, verify the change:

postgres=# show log_connections;
 log_connections
-----------------
 on
(1 row)

Note that you cannot verify this change in the same connection in which it was changed; a new connection is needed.

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.21 Ensure 'log_disconnections' is enabled - log_disconnections is enabled"" : [PASSED]

Enabling the log_disconnections setting logs the end of each session, including session duration. This parameter cannot be changed after the session start.

Rationale:

PostgreSQL does not maintain the beginning or ending of a connection internally for later review. It is only by enabling the logging of these that one can examine connections for failed attempts, 'over long' duration, or other anomalies.

Note that enabling this without also enabling log_connections provides little value. Generally, you would enable/disable the pair together.

Solution:
Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set log_disconnections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_disconnections
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""on""]","Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set log_disconnections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.22 Ensure 'log_error_verbosity' is set correctly - log_error_verbosity is set correctly"" : [PASSED]

The log_error_verbosity setting specifies the verbosity (amount of detail) of logged messages. Valid values are:

TERSE

DEFAULT

VERBOSE

with each containing the fields of the level above it as well as additional fields.

TERSE excludes the logging of DETAIL, HINT, QUERY, and CONTEXT error information.

VERBOSE output includes the SQLSTATE, error code, and the source code file name, function name, and line number that generated the error.

The appropriate value should be set based on your organization's logging policy.

Rationale:

If this is not set to the correct value, too many details or too few details may be logged.

Solution:
Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to verbose):

postgres=# alter system set log_error_verbosity = 'verbose';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

DEFAULT

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_error_verbosity
sql_expect: STRING - default

Actual Value:
5432/postgres:
* [""default""]","Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to verbose):

postgres=# alter system set log_error_verbosity = 'verbose';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

DEFAULT","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.23 Ensure 'log_hostname' is set correctly - log_hostname is set correctly"" : [PASSED]

Enabling the log_hostname setting causes the hostname of the connecting host to be logged in addition to the host's IP address for connection log messages. Disabling the setting causes only the connecting host's IP address to be logged, and not the hostname. Unless your organization's logging policy requires hostname logging, it is best to disable this setting so as not to incur the overhead of DNS resolution for each statement that is logged.

Rationale:

Depending on your hostname resolution setup, enabling this setting might impose a non-negligible performance penalty. Additionally, the IP addresses that are logged can be resolved to their DNS names when reviewing the logs (unless dynamic hostnames are being used as part of your DHCP setup).

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, to off):

postgres=# alter system set log_hostname='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: show log_hostname
sql_expect: STRING - off

Actual Value:
5432/postgres:
* [""off""]","Execute the following SQL statement(s) to remediate this setting (in this example, to off):

postgres=# alter system set log_hostname='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.24 Ensure 'log_line_prefix' is set correctly - log_line_prefix is set correctly"" : [PASSED]

The log_line_prefix setting specifies a printf-style string that is prefixed to each log line. If blank, no prefix is used. You should configure this as recommended by the pgBadger development team unless directed otherwise by your organization's logging policy.

% characters begin 'escape sequences' that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the logline. Some escapes are only recognized by session processes and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files.

Any of the following escape sequences can be used:

%a = application name

%u = user name

%d = database name

%r = remote host and port

%h = remote host

%b = backend type

%p = process ID

%P = process ID of parallel group leader

%t = timestamp without milliseconds

%m = timestamp with milliseconds

%n = timestamp with milliseconds (as a Unix epoch)

%Q = query ID (0 if none or not computed)

%i = command tag

%e = SQL state

%c = session ID

%l = session line number

%s = session start timestamp

%v = virtual transaction ID

%x = transaction ID (0 if none)

%q = stop here in non-session processes

%% = '%'

Rationale:

Properly setting log_line_prefix allows for adding additional information to each log entry (such as the user, or the database). Said information may then be of use in auditing or security reviews.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_line_prefix = '%m [%p]: [%l-1] db=%d,user=%u,app=%a,client=%h ';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

%m [%p]

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_line_prefix
sql_expect: STRING - %t:%r:%u@%d:[%p]:

Actual Value:
5432/postgres:
* [""%t:%r:%u@%d:[%p]:""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_line_prefix = '%m [%p]: [%l-1] db=%d,user=%u,app=%a,client=%h ';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

%m [%p]","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.25 Ensure 'log_statement' is set correctly - log_statement is set correctly"" : [PASSED]

The log_statement setting specifies the types of SQL statements that are logged. Valid values are:

none (off)

ddl

mod

all (all statements)

It is recommended this be set to ddl unless otherwise directed by your organization's logging policy.

ddl logs all data definition statements:

CREATE

ALTER

DROP

mod logs all ddl statements, plus data-modifying statements:

INSERT

UPDATE

DELETE

TRUNCATE

COPY FROM

(PREPARE, EXECUTE, and EXPLAIN ANALYZE statements are also logged if their contained command is of an appropriate type.)

For clients using extended query protocol, logging occurs when an Execute message is received, and values of the Bind parameters are included (with any embedded single-quote marks doubled).

Rationale:

Setting log_statement to align with your organization's security and logging policies facilitates later auditing and review of database activities.

Solution:
Execute the following SQL statement(s) as superuser to remediate this setting:

postgres=# alter system set log_statement='ddl';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

none

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_statement
sql_expect: STRING - ddl

Actual Value:
5432/postgres:
* [""ddl""]","Execute the following SQL statement(s) as superuser to remediate this setting:

postgres=# alter system set log_statement='ddl';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

none","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.26 Ensure 'log_timezone' is set correctly - log_timezone is set correctly"" : [PASSED]

The log_timezone setting specifies the time zone to use in timestamps within log messages. This value is cluster-wide, so that all sessions will report timestamps consistently. Unless directed otherwise by your organization's logging policy, set this to either GMT or UTC.

Rationale:

Log entry timestamps should be configured for an appropriate time zone as defined by your organization's logging policy to ensure a lack of confusion around when a logged event occurred.

Note that this setting affects only the timestamps present in the logs. It does not affect the time zone in use by the database itself (for example, select now()), nor does it affect the host's time zone.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_timezone = 'GMT';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

By default, the PGDG packages will set this to match the server's timezone in the Operating System.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_timezone
sql_expect: STRING - UTC

Actual Value:
5432/postgres:
* [""UTC""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_timezone = 'GMT';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

By default, the PGDG packages will set this to match the server's timezone in the Operating System.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.2 Ensure the PostgreSQL Audit Extension (pgAudit) is enabled - show pgaudit.log"" : [WARNING]

The PostgreSQL Audit Extension (pgAudit) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The goal of pgAudit is to provide PostgreSQL users with the capability to produce audit logs often required to comply with government, financial, or ISO certifications.

Rationale:

Basic statement logging can be provided by the standard logging facility with log_statement = all. This is acceptable for monitoring and other uses but does not provide the level of detail generally required for an audit. It is not enough to have a list of all the operations performed against the database, it must also be possible to find particular statements that are of interest to an auditor. The standard logging facility shows what the user requested, while pgAudit focuses on the details of what happened while the database was satisfying the request.

When logging SELECT and DML statements, pgAudit can be configured to log a separate entry for each relation referenced in a statement. No parsing is required to find all statements that touch a particular table. In fact, the goal is that the statement text is provided primarily for deep forensics and should not be required for an audit.

Impact:

Depending on settings, it is possible for pgAudit to generate an enormous volume of logging. Be careful to determine exactly what needs to be audit logged in your environment to avoid logging too much.

Solution:
To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:

# whoami
root
# dnf -y install pgaudit15_13
[snip]
Installed:
  pgaudit15_13-1.5.2-1.rhel9.x86_64

Complete!

pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:

enable pgAudit as an extension in the shared_preload_libraries parameter

indicate which classes of statements we want to log via the pgaudit.log parameter

and, finally, restart the PostgreSQL service:

$ vi ${PGDATA}/postgresql.conf

Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):

shared_preload_libraries = 'pgaudit'

OR

shared_preload_libraries = 'pgaudit,somethingelse'

Now, add a new pgaudit-specific entry:

# for this example we are logging the ddl and write operations
pgaudit.log='ddl,write'

Restart the PostgreSQL server for changes to take affect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [date] 10s ago

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show pgaudit.log
sql_expect: REGEX - (read|write|function|role|ddl|misc)

Error:
5432/postgres:
  ERROR: error retrieving data: [M: unrecognized configuration parameter ""pgaudit.log""]","To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:

# whoami
root
# dnf -y install pgaudit15_13
[snip]
Installed:
  pgaudit15_13-1.5.2-1.rhel9.x86_64

Complete!

pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:

enable pgAudit as an extension in the shared_preload_libraries parameter

indicate which classes of statements we want to log via the pgaudit.log parameter

and, finally, restart the PostgreSQL service:

$ vi ${PGDATA}/postgresql.conf

Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):

shared_preload_libraries = 'pgaudit'

OR

shared_preload_libraries = 'pgaudit,somethingelse'

Now, add a new pgaudit-specific entry:

# for this example we are logging the ddl and write operations
pgaudit.log='ddl,write'

Restart the PostgreSQL server for changes to take affect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [date] 10s ago","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.2 Ensure the PostgreSQL Audit Extension (pgAudit) is enabled - pgaudit installed"" : [FAILED]

The PostgreSQL Audit Extension (pgAudit) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The goal of pgAudit is to provide PostgreSQL users with the capability to produce audit logs often required to comply with government, financial, or ISO certifications.

Rationale:

Basic statement logging can be provided by the standard logging facility with log_statement = all. This is acceptable for monitoring and other uses but does not provide the level of detail generally required for an audit. It is not enough to have a list of all the operations performed against the database, it must also be possible to find particular statements that are of interest to an auditor. The standard logging facility shows what the user requested, while pgAudit focuses on the details of what happened while the database was satisfying the request.

When logging SELECT and DML statements, pgAudit can be configured to log a separate entry for each relation referenced in a statement. No parsing is required to find all statements that touch a particular table. In fact, the goal is that the statement text is provided primarily for deep forensics and should not be required for an audit.

Impact:

Depending on settings, it is possible for pgAudit to generate an enormous volume of logging. Be careful to determine exactly what needs to be audit logged in your environment to avoid logging too much.

Solution:
To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:

# whoami
root
# dnf -y install pgaudit15_13
[snip]
Installed:
  pgaudit15_13-1.5.2-1.rhel9.x86_64

Complete!

pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:

enable pgAudit as an extension in the shared_preload_libraries parameter

indicate which classes of statements we want to log via the pgaudit.log parameter

and, finally, restart the PostgreSQL service:

$ vi ${PGDATA}/postgresql.conf

Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):

shared_preload_libraries = 'pgaudit'

OR

shared_preload_libraries = 'pgaudit,somethingelse'

Now, add a new pgaudit-specific entry:

# for this example we are logging the ddl and write operations
pgaudit.log='ddl,write'

Restart the PostgreSQL server for changes to take affect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [date] 10s ago

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show shared_preload_libraries
sql_expect: REGEX - pgaudit

Actual Value:
5432/postgres:
  [""rdsutils,pg_stat_statements""]","To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:

# whoami
root
# dnf -y install pgaudit15_13
[snip]
Installed:
  pgaudit15_13-1.5.2-1.rhel9.x86_64

Complete!

pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:

enable pgAudit as an extension in the shared_preload_libraries parameter

indicate which classes of statements we want to log via the pgaudit.log parameter

and, finally, restart the PostgreSQL service:

$ vi ${PGDATA}/postgresql.conf

Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):

shared_preload_libraries = 'pgaudit'

OR

shared_preload_libraries = 'pgaudit,somethingelse'

Now, add a new pgaudit-specific entry:

# for this example we are logging the ddl and write operations
pgaudit.log='ddl,write'

Restart the PostgreSQL server for changes to take affect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [date] 10s ago","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.2 Ensure excessive administrative privileges are revoked"" : [WARNING]

With respect to PostgreSQL administrative SQL commands, only superusers should have elevated privileges. PostgreSQL regular, or application, users should not possess the ability to create roles, create new databases, manage replication, or perform any other action deemed privileged. Typically, regular users should only be granted the minimal set of privileges commensurate with managing the application:

DDL (create table, create view, create index, etc.)

DML (select, insert, update, delete)

Further, it has become best practice to create separate roles for DDL and DML. Given an application called 'payroll', one would create the following users:

payroll_owner

payroll_user

Any DDL privileges would be granted to the payroll_owner account only, while DML privileges would be given to the payroll_user account only. This prevents accidental creation/altering/dropping of database objects by application code that runs as the payroll_user account.

Rationale:

By not restricting global administrative commands to superusers only, regular users granted excessive privileges may execute administrative commands with unintended and undesirable results.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
If any regular or application users have been granted excessive administrative rights, those privileges should be removed immediately via the PostgreSQL ALTER ROLE SQL command. Using the same example above, the following SQL statements revoke all unnecessary elevated administrative privileges from the regular user appuser:

# whoami
postgres
# psql -c 'ALTER ROLE appuser NOSUPERUSER;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOCREATEROLE;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOCREATEDB;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOREPLICATION;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOBYPASSRLS;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOINHERIT;'
ALTER ROLE

Verify the appuser now passes your check by having no defined Attributes:

# whoami
postgres
# psql -c '\du appuser'
          List of roles
Role name | Attributes | Member of
----------+------------+-----------
appuser   |            | {}

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select * from pg_user order by usename;
sql_expect: STRING - NULL

Actual Value:
5432/postgres:
  [""inventory"",""17043"",""f"",""f"",""f"",""f"",""********"",null,null]
  [""luigi-luigi-096189eb8b9c48ba-ro-user"",""17049"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-096189eb8b9c48ba-rw-user"",""17048"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-17fbed605c0f4b6d-ro-user"",""17070"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-17fbed605c0f4b6d-rw-user"",""17069"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-2a0afced6d6e435f-ro-user"",""17075"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-2a0afced6d6e435f-rw-user"",""17074"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-2d2276b2f44e4558-ro-user"",""17034"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-2d2276b2f44e4558-rw-user"",""17033"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-2f239faccfe44979-ro-user"",""16960"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-2f239faccfe44979-rw-user"",""16959"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-4082c3cd42e9458b-ro-user"",""17072"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-4082c3cd42e9458b-rw-user"",""17071"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-441fcdd2c7f14c34-ro-user"",""17055"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-441fcdd2c7f14c34-rw-user"",""17054"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-47babf7c334a4d98-ro-user"",""17032"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-47babf7c334a4d98-rw-user"",""17031"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-48b8ff4dc20542f1-ro-user"",""17052"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-48b8ff4dc20542f1-rw-user"",""17051"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-5c6da32f34c9434e-ro-user"",""17036"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-5c6da32f34c9434e-rw-user"",""17035"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-5e2dd402dc584911-ro-user"",""17060"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-5e2dd402dc584911-rw-user"",""17059"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-86dc3654c44942e1-ro-user"",""17046"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-86dc3654c44942e1-rw-user"",""17045"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-9136eb1bd18e493a-ro-user"",""17057"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-9136eb1bd18e493a-rw-user"",""17056"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-9aa8bc3e65ab4d02-ro-user"",""16996"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-9aa8bc3e65ab4d02-rw-user"",""16995"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-b963a9f11a0944dd-ro-user"",""17083"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-b963a9f11a0944dd-rw-user"",""17082"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-f7526b229ed54823-ro-user"",""17064"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-f7526b229ed54823-rw-user"",""17063"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""rdsadmin"",""10"",""t"",""t"",""t"",""t"",""********"",""infinity"",""{TimeZone=utc,log_statement=all,log_min_error_statement=debug5,log_min_messages=panic,exit_on_error=0,statement_timeout=0,role=rdsadmin,auto_explain.log_min_duration=-1,temp_file_limit=-1,search_path=pg_catalog,synchronous_commit=local,default_tablespace=,pg_hint_plan.enable_hint=off,default_transaction_read_only=off}""]
  [""security_scanner"",""17047"",""f"",""f"",""f"",""f"",""********"",null,null]
  [""superuser"",""16401"",""t"",""f"",""f"",""f"",""********"",""infinity"",null]","If any regular or application users have been granted excessive administrative rights, those privileges should be removed immediately via the PostgreSQL ALTER ROLE SQL command. Using the same example above, the following SQL statements revoke all unnecessary elevated administrative privileges from the regular user appuser:

# whoami
postgres
# psql -c 'ALTER ROLE appuser NOSUPERUSER;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOCREATEROLE;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOCREATEDB;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOREPLICATION;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOBYPASSRLS;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOINHERIT;'
ALTER ROLE

Verify the appuser now passes your check by having no defined Attributes:

# whoami
postgres
# psql -c '\du appuser'
          List of roles
Role name | Attributes | Member of
----------+------------+-----------
appuser   |            | {}","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.3 Ensure excessive function privileges are revoked"" : [WARNING]

In certain situations, to provide the required functionality, PostgreSQL needs to execute internal logic (stored procedures, functions, triggers, etc.) and/or external code modules with elevated privileges. However, if the privileges required for execution are at a higher level than the privileges assigned to organizational users invoking the functionality applications/programs, those users are indirectly provided with greater privileges than assigned by their organization. This is known as privilege elevation. Privilege elevation must be utilized only where necessary. Execute privileges for application functions should be restricted to authorized users only.

Rationale:

Ideally, all application source code should be vetted to validate interactions between the application and the logic in the database, but this is usually not possible or feasible with available resources even if the source code is available. The DBA should attempt to obtain assurances from the development organization that this issue has been addressed and should document what has been discovered. The DBA should also inspect all application logic stored in the database (in the form of functions, rules, and triggers) for excessive privileges.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Where possible, revoke SECURITY DEFINER on PostgreSQL functions. To change a SECURITY DEFINER function to SECURITY INVOKER, run the following SQL:

# whoami
root
# sudo -iu postgres
# psql -c 'ALTER FUNCTION [functionname] SECURITY INVOKER;'

If it is not possible to revoke SECURITY DEFINER, ensure the function can be executed by only the accounts that absolutely need such functionality:

postgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres,appreader=X/postgres}
(1 row)
postgres=# REVOKE EXECUTE ON FUNCTION delete_customer(integer,boolean) FROM appreader;
REVOKE
postgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres}
(1 row)

Based on the output above, appreader=X/postgres no longer exists in the proacl column results returned from the query and confirms appreader is no longer granted execute privilege on the function.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: SELECT nspname, proname, proargtypes, prosecdef, rolname, proconfig FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid JOIN pg_authid a ON a.oid = p.proowner WHERE prosecdef OR NOT proconfig IS NULL;
sql_expect: STRING - MANUAL_REVIEW

Error:
5432/postgres:
  ERROR: error retrieving data: [M: permission denied for table pg_authid]","Where possible, revoke SECURITY DEFINER on PostgreSQL functions. To change a SECURITY DEFINER function to SECURITY INVOKER, run the following SQL:

# whoami
root
# sudo -iu postgres
# psql -c 'ALTER FUNCTION [functionname] SECURITY INVOKER;'

If it is not possible to revoke SECURITY DEFINER, ensure the function can be executed by only the accounts that absolutely need such functionality:

postgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres,appreader=X/postgres}
(1 row)
postgres=# REVOKE EXECUTE ON FUNCTION delete_customer(integer,boolean) FROM appreader;
REVOKE
postgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres}
(1 row)

Based on the output above, appreader=X/postgres no longer exists in the proacl column results returned from the query and confirms appreader is no longer granted execute privilege on the function.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.4 Ensure excessive DML privileges are revoked"" : [WARNING]

DML (insert, update, delete) operations at the table level should be restricted to only authorized users. PostgreSQL manages table-level DML permissions via the GRANT statement.

Rationale:

Excessive DML grants can lead to unprivileged users changing or deleting information without proper authorization.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
If a given database user has been granted excessive DML privileges for a given database table, those privileges should be revoked immediately using the REVOKE SQL command.

Continuing with the example above, remove unauthorized grants for appreader user using the REVOKE statement and verify the Boolean values are now false.

postgres=# REVOKE INSERT, UPDATE, DELETE ON TABLE customer FROM appreader;
REVOKE

postgres=# select t.tablename, u.usename,
       has_table_privilege(u.usename, t.tablename, 'select') as select,
       has_table_privilege(u.usename, t.tablename, 'insert') as insert,
       has_table_privilege(u.usename, t.tablename, 'update') as update,
       has_table_privilege(u.usename, t.tablename, 'delete') as delete
from   pg_tables t, pg_user u
where  t.tablename = 'customer'
and    u.usename in ('appwriter','appreader');

tablename |  usename  | select | insert | update | delete
----------+-----------+--------+--------+--------+--------
customer  | appwriter | t      | t      | t      | t
customer  | appreader | t      | f      | f      | f
(2 rows)

Note: For versions of PostgreSQL prior to version 15, CVE-2018-1058 is applicable and it is recommended that all privileges be revoked from the public schema for all users on all databases. If you have upgraded from one of these earlier releases, this CVE is not fixed for you during an upgrade. You can correct this CVE by issuing:

postgres=# REVOKE CREATE ON SCHEMA public FROM PUBLIC;
REVOKE

Default Value:

The table owner/creator has full privileges; all other users must be explicitly granted access.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
WARNING

Actual Value:
5432/postgres:
WARNING","If a given database user has been granted excessive DML privileges for a given database table, those privileges should be revoked immediately using the REVOKE SQL command.

Continuing with the example above, remove unauthorized grants for appreader user using the REVOKE statement and verify the Boolean values are now false.

postgres=# REVOKE INSERT, UPDATE, DELETE ON TABLE customer FROM appreader;
REVOKE

postgres=# select t.tablename, u.usename,
       has_table_privilege(u.usename, t.tablename, 'select') as select,
       has_table_privilege(u.usename, t.tablename, 'insert') as insert,
       has_table_privilege(u.usename, t.tablename, 'update') as update,
       has_table_privilege(u.usename, t.tablename, 'delete') as delete
from   pg_tables t, pg_user u
where  t.tablename = 'customer'
and    u.usename in ('appwriter','appreader');

tablename |  usename  | select | insert | update | delete
----------+-----------+--------+--------+--------+--------
customer  | appwriter | t      | t      | t      | t
customer  | appreader | t      | f      | f      | f
(2 rows)

Note: For versions of PostgreSQL prior to version 15, CVE-2018-1058 is applicable and it is recommended that all privileges be revoked from the public schema for all users on all databases. If you have upgraded from one of these earlier releases, this CVE is not fixed for you during an upgrade. You can correct this CVE by issuing:

postgres=# REVOKE CREATE ON SCHEMA public FROM PUBLIC;
REVOKE

Default Value:

The table owner/creator has full privileges; all other users must be explicitly granted access.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.5 Ensure Row Level Security (RLS) is configured correctly - RLS is configured correctly"" : [WARNING]

In addition to the SQL-standard privilege system available through GRANT, tables can have row security policies that restrict, on a per-user basis, which individual rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as Row Level Security (RLS).

By default, tables do not have any policies, so if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating. Row security policies can be specific to commands, to roles, or to both. A policy can be specified to apply to ALL commands, or to any combination of SELECT, INSERT, UPDATE, or DELETE. Multiple roles can be assigned to a given policy, and normal role membership and inheritance rules apply.

If you use RLS and apply restrictive policies to certain users, it is important that the Bypass RLS privilege not be granted to any unauthorized users. This privilege overrides RLS-enabled tables and associated policies. Generally, only superusers and elevated users should possess this privilege.

Rationale:

If RLS policies and privileges are not configured correctly, users could perform actions on tables that they are not authorized to perform, such as inserting, updating, or deleting rows.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
Again, we are using the example from the PostgreSQL documentation using the example passwd table. We will create three database roles to illustrate the workings of RLS:

postgres=# CREATE ROLE admin;
CREATE ROLE
postgres=# CREATE ROLE bob;
CREATE ROLE
postgres=# CREATE ROLE alice;
CREATE ROLE

Now, we will insert known data into the passwd table:

postgres=# INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');
INSERT 0 1

And we will enable RLS on the table:

postgres=# ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;
ALTER TABLE

Now that RLS is enabled, we need to define one or more policies. Create the administrator policy and allow it access to all rows:

postgres=# CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
CREATE POLICY

Create a policy for normal users to view all rows:

postgres=# CREATE POLICY all_view ON passwd FOR SELECT USING (true);
CREATE POLICY

Create a policy for normal users that allows them to update only their own rows and to limit what values can be set for their login shell:

postgres=# CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );
CREATE POLICY

Grant all the normal rights on the table to the admin user:

postgres=# GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
GRANT

Grant only select access on non-sensitive columns to everyone:

postgres=# GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
GRANT

Grant update to only the sensitive columns:

postgres=# GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
GRANT

Ensure that no one has been granted Bypass RLS inadvertently, by running the psql display command \du+. If unauthorized users do have Bypass RLS granted then resolve this using the ALTER ROLE <user> NOBYPASSRLS; command.

You can now verify that 'admin', 'bob', and 'alice' are properly restricted by querying the passwd table as each of these roles.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
WARNING

Actual Value:
5432/postgres:
WARNING","Again, we are using the example from the PostgreSQL documentation using the example passwd table. We will create three database roles to illustrate the workings of RLS:

postgres=# CREATE ROLE admin;
CREATE ROLE
postgres=# CREATE ROLE bob;
CREATE ROLE
postgres=# CREATE ROLE alice;
CREATE ROLE

Now, we will insert known data into the passwd table:

postgres=# INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');
INSERT 0 1

And we will enable RLS on the table:

postgres=# ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;
ALTER TABLE

Now that RLS is enabled, we need to define one or more policies. Create the administrator policy and allow it access to all rows:

postgres=# CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
CREATE POLICY

Create a policy for normal users to view all rows:

postgres=# CREATE POLICY all_view ON passwd FOR SELECT USING (true);
CREATE POLICY

Create a policy for normal users that allows them to update only their own rows and to limit what values can be set for their login shell:

postgres=# CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );
CREATE POLICY

Grant all the normal rights on the table to the admin user:

postgres=# GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
GRANT

Grant only select access on non-sensitive columns to everyone:

postgres=# GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
GRANT

Grant update to only the sensitive columns:

postgres=# GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
GRANT

Ensure that no one has been granted Bypass RLS inadvertently, by running the psql display command \du+. If unauthorized users do have Bypass RLS granted then resolve this using the ALTER ROLE <user> NOBYPASSRLS; command.

You can now verify that 'admin', 'bob', and 'alice' are properly restricted by querying the passwd table as each of these roles.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.6 Ensure the set_user extension is installed"" : [FAILED]

PostgreSQL access to the superuser database role must be controlled and audited to prevent unauthorized access.

Note: Prior to performing this audit you must create a roletree view. Here are the procedures to create this view:

postgres=#

CREATE OR REPLACE VIEW roletree AS

WITH RECURSIVE

roltree AS (

  SELECT u.rolname AS rolname,

         u.oid AS roloid,

         u.rolcanlogin,

         u.rolsuper,

         '{}'::name[] AS rolparents,

         NULL::oid AS parent_roloid,

         NULL::name AS parent_rolname

  FROM pg_catalog.pg_authid u

  LEFT JOIN pg_catalog.pg_auth_members m on u.oid = m.member

  LEFT JOIN pg_catalog.pg_authid g on m.roleid = g.oid

  WHERE g.oid IS NULL

  UNION ALL

  SELECT u.rolname AS rolname,

         u.oid AS roloid,

         u.rolcanlogin,

         u.rolsuper,

         t.rolparents || g.rolname AS rolparents,

         g.oid AS parent_roloid,

         g.rolname AS parent_rolname

  FROM pg_catalog.pg_authid u

  JOIN pg_catalog.pg_auth_members m on u.oid = m.member

  JOIN pg_catalog.pg_authid g on m.roleid = g.oid

  JOIN roltree t on t.roloid = g.oid

)

SELECT

  r.rolname,

  r.roloid,

  r.rolcanlogin,

  r.rolsuper,

  r.rolparents

FROM roltree r

ORDER BY 1;

Rationale:

Even when reducing and limiting the access to the superuser role as described earlier in this benchmark, it is still difficult to determine who accessed the superuser role and what actions were taken using that role. As such, it is ideal to prevent anyone from logging in as the superuser and forcing them to escalate their role. This model is used at the OS level by the use of sudo and should be emulated in the database. The set_user extension allows for this setup.

Impact:

Much like the venerable sudo does for the OS, set_user manages superuser access for PostgreSQL. Complete configuration of set_user is documented at the extension's website and should be reviewed to ensure the logging entries that your organization cares about are properly configured.

Note that some external tools assume they can connect as the postgres user by default and this is no longer true when set_user is deployed. You may find some tools need different options, reconfigured, or even abandoned to compensate for this.

Solution:
We will install the set_user extension:

# whoami
root
# dnf -y install set_user_13
[snip]
Installed:
  set_user_13-4.0.1-2.rhel9.x86_64

Complete!

Now that set_user is installed, we need to tell PostgreSQL to load its library:

# whoami
root
# vi ~postgres/13/data/postgresql.conf

Find the shared_preload_libraries entry, and add 'set_user' to it (preserving any existing entries):

shared_preload_libraries = 'set_user'

OR

shared_preload_libraries = 'set_user,pgaudit,somethingelse'

Restart the PostgreSQL server for changes to take effect:

# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [timestamp]; 1s ago

And now, we can install the extension with SQL:

# su - postgres
# psql
postgres=# select * from pg_available_extensions where name = 'set_user';
  name   | default_version | installed_version |                  comment
---------+-----------------+-------------------+-----------------------------
set_user | 4.0.1           |                   | similar to SET ROLE but with
         |                 |                   | added logging
(1 row)

postgres=# create extension set_user;
CREATE EXTENSION
postgres=# select * from pg_available_extensions where name = 'set_user';
  name   | default_version | installed_version |                  comment
---------+-----------------+-------------------+-----------------------------
set_user | 4.0.1           | 4.0.1             | similar to SET ROLE but with
         |                 |                   | added logging
(1 row)

Now, we use GRANT to configure each DBA role to allow it to use the set_user functions. In the example below, we will configure my db user doug. (You would do this for each DBA's normal user role.)

postgres=# grant execute on function set_user(text) to doug;
GRANT
postgres=# grant execute on function set_user_u(text) to doug;
GRANT

Connect to PostgreSQL as yourself and verify it works as expected:

# whoami
psql
# psql -U doug -d postgres -h 127.0.0.1
postgres=> select set_user('postgres');
ERROR:  switching to superuser not allowed
HINT:  Use 'set_user_u' to escalate.
postgres=> select set_user_u('postgres');
 set_user_u
------------
 OK
(1 row)
postgres=# select current_user, session_user;
 current_user | session_user
--------------+--------------
 postgres     | doug
(1 row)
postgres=# select reset_user();
 reset_user
------------
 OK
(1 row)
postgres=> select current_user, session_user;
 current_user | session_user
--------------+--------------
 doug         | doug
(1 row)

Once all DBA's normal user accounts have been GRANTed permission, revoke the ability to login as the postgres (superuser) user:

postgres=# ALTER USER postgres NOLOGIN;
ALTER ROLE

Which results in:

$ psql
psql: FATAL:  role 'postgres' is not permitted to log in
$ psql -U doug -d postgres -h 127.0.0.1
psql (13.10)

Revoke SUPERUSER and/or LOGIN from any other roles that were previously identified:

postgres=# ALTER USER usera NOSUPERUSER; -- revoke superuser
ALTER ROLE
postgres=# ALTER USER usera NOLOGIN; -- revoke login
ALTER ROLE
postgres=# ALTER USER usera NOSUPERUSER NOLOGIN; -- revoke both at once
ALTER ROLE

Note that we show dropping the privileges both individually and as one. Pick an appropriate version based on your application/business needs.

Remove any escalated privileges on users granted indirectly that were previously identified using the roletree view:

postgres=# REVOKE name_of_granting_role FROM bob; -- an example only
REVOKE ROLE

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1A,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
SQL_POLICY
sql_request: select name from pg_available_extensions where name = 'set_user';
sql_expect: STRING - set_user

Actual Value:
5432/postgres:
  No data returned.","We will install the set_user extension:

# whoami
root
# dnf -y install set_user_13
[snip]
Installed:
  set_user_13-4.0.1-2.rhel9.x86_64

Complete!

Now that set_user is installed, we need to tell PostgreSQL to load its library:

# whoami
root
# vi ~postgres/13/data/postgresql.conf

Find the shared_preload_libraries entry, and add 'set_user' to it (preserving any existing entries):

shared_preload_libraries = 'set_user'

OR

shared_preload_libraries = 'set_user,pgaudit,somethingelse'

Restart the PostgreSQL server for changes to take effect:

# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [timestamp]; 1s ago

And now, we can install the extension with SQL:

# su - postgres
# psql
postgres=# select * from pg_available_extensions where name = 'set_user';
  name   | default_version | installed_version |                  comment
---------+-----------------+-------------------+-----------------------------
set_user | 4.0.1           |                   | similar to SET ROLE but with
         |                 |                   | added logging
(1 row)

postgres=# create extension set_user;
CREATE EXTENSION
postgres=# select * from pg_available_extensions where name = 'set_user';
  name   | default_version | installed_version |                  comment
---------+-----------------+-------------------+-----------------------------
set_user | 4.0.1           | 4.0.1             | similar to SET ROLE but with
         |                 |                   | added logging
(1 row)

Now, we use GRANT to configure each DBA role to allow it to use the set_user functions. In the example below, we will configure my db user doug. (You would do this for each DBA's normal user role.)

postgres=# grant execute on function set_user(text) to doug;
GRANT
postgres=# grant execute on function set_user_u(text) to doug;
GRANT

Connect to PostgreSQL as yourself and verify it works as expected:

# whoami
psql
# psql -U doug -d postgres -h 127.0.0.1
postgres=> select set_user('postgres');
ERROR:  switching to superuser not allowed
HINT:  Use 'set_user_u' to escalate.
postgres=> select set_user_u('postgres');
 set_user_u
------------
 OK
(1 row)
postgres=# select current_user, session_user;
 current_user | session_user
--------------+--------------
 postgres     | doug
(1 row)
postgres=# select reset_user();
 reset_user
------------
 OK
(1 row)
postgres=> select current_user, session_user;
 current_user | session_user
--------------+--------------
 doug         | doug
(1 row)

Once all DBA's normal user accounts have been GRANTed permission, revoke the ability to login as the postgres (superuser) user:

postgres=# ALTER USER postgres NOLOGIN;
ALTER ROLE

Which results in:

$ psql
psql: FATAL:  role 'postgres' is not permitted to log in
$ psql -U doug -d postgres -h 127.0.0.1
psql (13.10)

Revoke SUPERUSER and/or LOGIN from any other roles that were previously identified:

postgres=# ALTER USER usera NOSUPERUSER; -- revoke superuser
ALTER ROLE
postgres=# ALTER USER usera NOLOGIN; -- revoke login
ALTER ROLE
postgres=# ALTER USER usera NOSUPERUSER NOLOGIN; -- revoke both at once
ALTER ROLE

Note that we show dropping the privileges both individually and as one. Pick an appropriate version based on your application/business needs.

Remove any escalated privileges on users granted indirectly that were previously identified using the roletree view:

postgres=# REVOKE name_of_granting_role FROM bob; -- an example only
REVOKE ROLE","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.7 Make use of predefined roles"" : [WARNING]

PostgreSQL provides a set of predefined roles that provide access to certain commonly needed privileged capabilities and information. Administrators can GRANT these roles to users and/or other roles in their environment, providing those users with access to the specified capabilities and information.

Rationale:

In keeping with the principle of least privilege, judicious use of the PostgreSQL predefined roles can greatly limit the access to privileged, or superuser, access.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
If you've determined that one or more of the predefined roles can be used, simply GRANT it:

postgres=# GRANT pg_monitor TO doug;
GRANT ROLE

And then remove superuser from the account:

postgres=# ALTER ROLE doug NOSUPERUSER;
ALTER ROLE
postgres=# select rolname from pg_roles where rolsuper is true;
 rolname
----------
 postgres
(1 row)

Default Value:

The following predefined roles exist in PostgreSQL 13.x:

pg_read_all_settings

Read all configuration variables, even those normally visible only to superuser.

pg_read_all_stats

Read all pg_stat_* views and use various statistics related extensions, even those normally visible only to superuser.

pg_stat_scan_tables

Execute monitoring functions that may take ACCESS SHARE locks on tables, potentially for a long time.

pg_monitor

Read/execute various monitoring views and functions. This role is a member of pg_read_all_settings, pg_read_all_stats and pg_stat_scan_tables.

pg_signal_backend

Signal another backend to cancel a query or terminate its session.

pg_read_server_files

Allow reading files from any location the database can access on the server with COPY and other file-access functions.

pg_write_server_files

Allow writing to files in any location the database can access on the server with COPY and other file-access functions.

pg_execute_server_program

Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.

Administrators can grant access to these roles to users using the GRANT command.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select rolname from pg_roles where rolsuper is true;
sql_expect: STRING - rolname

Actual Value:
5432/postgres:
  [""rdsadmin""]","If you've determined that one or more of the predefined roles can be used, simply GRANT it:

postgres=# GRANT pg_monitor TO doug;
GRANT ROLE

And then remove superuser from the account:

postgres=# ALTER ROLE doug NOSUPERUSER;
ALTER ROLE
postgres=# select rolname from pg_roles where rolsuper is true;
 rolname
----------
 postgres
(1 row)

Default Value:

The following predefined roles exist in PostgreSQL 13.x:

pg_read_all_settings

Read all configuration variables, even those normally visible only to superuser.

pg_read_all_stats

Read all pg_stat_* views and use various statistics related extensions, even those normally visible only to superuser.

pg_stat_scan_tables

Execute monitoring functions that may take ACCESS SHARE locks on tables, potentially for a long time.

pg_monitor

Read/execute various monitoring views and functions. This role is a member of pg_read_all_settings, pg_read_all_stats and pg_stat_scan_tables.

pg_signal_backend

Signal another backend to cancel a query or terminate its session.

pg_read_server_files

Allow reading files from any location the database can access on the server with COPY and other file-access functions.

pg_write_server_files

Allow writing to files in any location the database can access on the server with COPY and other file-access functions.

pg_execute_server_program

Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.

Administrators can grant access to these roles to users using the GRANT command.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.1 Understanding attack vectors and runtime parameters"" : [WARNING]

Understanding the vulnerability of PostgreSQL runtime parameters by the particular delivery method, or attack vector.

Rationale:

There are as many ways of compromising a server as there are runtime parameters. A combination of any one or more of them executed at the right time under the right conditions has the potential to compromise the RDBMS. Mitigating risk is dependent upon one's understanding of the attack vectors and includes:

Via user session: includes those runtime parameters that can be set by a ROLE that persists for the life of a server-client session.

Via attribute: includes those runtime parameters that can be set by a ROLE during a server-client session that can be assigned as an attribute for an entity such as a table, index, database, or role.

Via server reload: includes those runtime parameters that can be set by the superuser using a SIGHUP or configuration file reload command and affects the entire cluster.

Via server restart: includes those runtime parameters that can be set and effected by restarting the server process and affects the entire cluster.

Impact:

It can be difficult to totally eliminate risk. Once changed, detecting a miscreant parameter can become problematic.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
In the case of a changed parameter, the value is returned back to its default value. In the case of a successful exploit of an already set runtime parameter then an analysis must be carried out to determine the best approach in mitigating the risk to prevent future exploitation.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
WARNING

Actual Value:
5432/postgres:
WARNING","In the case of a changed parameter, the value is returned back to its default value. In the case of a successful exploit of an already set runtime parameter then an analysis must be carried out to determine the best approach in mitigating the risk to prevent future exploitation.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - ignore_system_indexes"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'ignore_system_indexes';
sql_expect: STRING - ignore_system_indexes
sql_expect: STRING - off

Actual Value:
5432/postgres:
* [""ignore_system_indexes"",""off""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - jit_debugging_support"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'jit_debugging_support';
sql_expect: STRING - jit_debugging_support
sql_expect: STRING - off

Actual Value:
5432/postgres:
* [""jit_debugging_support"",""off""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - jit_profiling_support"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'jit_profiling_support';
sql_expect: STRING - jit_profiling_support
sql_expect: STRING - off

Actual Value:
5432/postgres:
* [""jit_profiling_support"",""off""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - log_connections"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'log_connections';
sql_expect: STRING - log_connections
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""log_connections"",""on""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - log_disconnections"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'log_disconnections';
sql_expect: STRING - log_disconnections
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""log_disconnections"",""on""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - post_auth_delay"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'post_auth_delay';
sql_expect: STRING - post_auth_delay
sql_expect: INTEGER - 0

Actual Value:
5432/postgres:
* [""post_auth_delay"",""0""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.3 Ensure 'Postmaster' Runtime Parameters are Configured"" : [WARNING]

PostgreSQL runtime parameters that are executed by the postmaster process.

Rationale:

The postmaster process is the supervisory process that assigns a backend process to an incoming client connection. The postmaster manages key runtime parameters that are either shared by all backend connections or needed by the postmaster process itself to run.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Once detected, the unauthorized/undesired change can be corrected by editing the altered configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:

Query the view pg_settings and compare with previous query outputs for any changes

Review the configuration files postgresql.conf and postgresql.auto.conf and compare with previously archived file copies for any changes

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context = 'postmaster' order by 1
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/postgres:
  [""archive_mode"",""on""]
  [""autovacuum_freeze_max_age"",""200000000""]
  [""autovacuum_max_workers"",""6""]
  [""autovacuum_multixact_freeze_max_age"",""400000000""]
  [""bonjour"",""off""]
  [""bonjour_name"",null]
  [""cluster_name"",null]
  [""config_file"",""/rdsdbdata/config/postgresql.conf""]
  [""data_directory"",""/rdsdbdata/db""]
  [""data_sync_retry"",""off""]
  [""dynamic_shared_memory_type"",""posix""]
  [""event_source"",""PostgreSQL""]
  [""external_pid_file"",null]
  [""hba_file"",""/rdsdbdata/config/pg_hba.conf""]
  [""hot_standby"",""off""]
  [""huge_pages"",""on""]
  [""ident_file"",""/rdsdbdata/config/pg_ident.conf""]
  [""ignore_invalid_pages"",""off""]
  [""jit_provider"",""llvmjit""]
  [""listen_addresses"",""*""]
  [""logging_collector"",""on""]
  [""max_connections"",""1708""]
  [""max_files_per_process"",""1000""]
  [""max_locks_per_transaction"",""64""]
  [""max_logical_replication_workers"",""10""]
  [""max_pred_locks_per_transaction"",""64""]
  [""max_prepared_transactions"",""0""]
  [""max_replication_slots"",""20""]
  [""max_wal_senders"",""35""]
  [""max_worker_processes"",""10""]
  [""old_snapshot_threshold"",""-1""]
  [""pg_stat_statements.max"",""5000""]
  [""port"",""5432""]
  [""rds.instance_store_replication_tooling"",""off""]
  [""rds.logical_replication"",""on""]
  [""rds.max_connections_counters_entries"",""5000""]
  [""rds.max_connections_counters_entries_sl"",""1000""]
  [""rds.max_rsdl_counters_entries"",""5000""]
  [""rds.max_stored_credentials"",""10""]
  [""rds.rds_superuser_reserved_connections"",""2""]
  [""rds.restrict_password_commands"",""off""]
  [""rds.tablespace_path_prefix"",""/rdsdbdata/db/base/tablespace""]
  [""rds.wal_allocator_dir"",""/rdslocalstorage/prealloc""]
  [""recovery_target"",null]
  [""recovery_target_action"",""pause""]
  [""recovery_target_inclusive"",""on""]
  [""recovery_target_lsn"",null]
  [""recovery_target_name"",null]
  [""recovery_target_time"",null]
  [""recovery_target_timeline"",""latest""]
  [""recovery_target_xid"",null]
  [""restore_command"",null]
  [""shared_buffers"",""497015""]
  [""shared_memory_type"",""mmap""]
  [""shared_preload_libraries"",""rdsutils,pg_stat_statements""]
  [""superuser_reserved_connections"",""3""]
  [""track_activity_query_size"",""4096""]
  [""track_commit_timestamp"",""off""]
  [""unix_socket_directories"",""/tmp""]
  [""unix_socket_group"",""rdsdb""]
  [""unix_socket_permissions"",""0666""]
  [""wal_buffers"",""8192""]
  [""wal_level"",""logical""]
  [""wal_log_hints"",""off""]","Once detected, the unauthorized/undesired change can be corrected by editing the altered configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:

Query the view pg_settings and compare with previous query outputs for any changes

Review the configuration files postgresql.conf and postgresql.auto.conf and compare with previously archived file copies for any changes

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.4 Ensure 'SIGHUP' Runtime Parameters are Configured"" : [WARNING]

PostgreSQL runtime parameters that are executed by the SIGHUP signal.

Rationale:

In order to define server behavior and optimize server performance, the server's superuser has the privilege of setting these parameters which are found in the configuration files postgresql.conf and pg_hba.conf. Alternatively, those parameters found in postgresql.conf can also be changed using a server login session and executing the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Restore all values in the PostgreSQL configuration files and invoke the server to reload the configuration files.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context = 'sighup' order by 1
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/postgres:
  [""allow_system_table_mods"",""off""]
  [""archive_cleanup_command"",null]
  [""archive_command"",""/etc/rds/dbbin/pgscripts/rds_wal_archive %p skipTimeCheckForWalSegmentAndReadyFile""]
  [""archive_timeout"",""300""]
  [""authentication_timeout"",""60""]
  [""autovacuum"",""on""]
  [""autovacuum_analyze_scale_factor"",""0.05""]
  [""autovacuum_analyze_threshold"",""50""]
  [""autovacuum_naptime"",""15""]
  [""autovacuum_vacuum_cost_delay"",""2""]
  [""autovacuum_vacuum_cost_limit"",""200""]
  [""autovacuum_vacuum_insert_scale_factor"",""0.2""]
  [""autovacuum_vacuum_insert_threshold"",""1000""]
  [""autovacuum_vacuum_scale_factor"",""0.1""]
  [""autovacuum_vacuum_threshold"",""50""]
  [""autovacuum_work_mem"",""524288""]
  [""bgwriter_delay"",""200""]
  [""bgwriter_flush_after"",""64""]
  [""bgwriter_lru_maxpages"",""100""]
  [""bgwriter_lru_multiplier"",""2""]
  [""checkpoint_completion_target"",""0.9""]
  [""checkpoint_flush_after"",""32""]
  [""checkpoint_timeout"",""300""]
  [""checkpoint_warning"",""30""]
  [""db_user_namespace"",""off""]
  [""fsync"",""on""]
  [""full_page_writes"",""on""]
  [""hot_standby_feedback"",""off""]
  [""krb_caseins_users"",""off""]
  [""krb_server_keyfile"",""/rdsdbdata/config/keytab""]
  [""log_autovacuum_min_duration"",""10000""]
  [""log_checkpoints"",""on""]
  [""log_destination"",""stderr""]
  [""log_directory"",""/rdsdbdata/log/error""]
  [""log_file_mode"",""0644""]
  [""log_filename"",""postgresql.log.%Y-%m-%d-%H""]
  [""log_hostname"",""off""]
  [""log_line_prefix"",""%t:%r:%u@%d:[%p]:""]
  [""log_rotation_age"",""60""]
  [""log_rotation_size"",""10240""]
  [""log_timezone"",""UTC""]
  [""log_truncate_on_rotation"",""off""]
  [""max_pred_locks_per_page"",""2""]
  [""max_pred_locks_per_relation"",""-2""]
  [""max_slot_wal_keep_size"",""-1""]
  [""max_standby_archive_delay"",""30000""]
  [""max_standby_streaming_delay"",""30000""]
  [""max_sync_workers_per_subscription"",""2""]
  [""max_wal_size"",""25600""]
  [""min_wal_size"",""2048""]
  [""pg_stat_statements.save"",""on""]
  [""pre_auth_delay"",""0""]
  [""primary_slot_name"",null]
  [""promote_trigger_file"",null]
  [""rds.allowed_extensions"",""*""]
  [""rds.check_execution_context"",""on""]
  [""rds.check_extension_connections"",""on""]
  [""rds.connections_counters_dealloc_percent"",""5""]
  [""rds.enable_connections_counters"",""on""]
  [""rds.enable_logical_seed_lsn"",""on""]
  [""rds.enable_rsdl_counters"",""on""]
  [""rds.force_admin_logging_level"",""disabled""]
  [""rds.force_autovacuum_logging_level"",""warning""]
  [""rds.internal_databases"",""rdsadmin,template0""]
  [""rds.recovery_target_lsn"",null]
  [""rds.restrict_subconninfo"",""off""]
  [""rds.rsdl_counters_dealloc_percent"",""5""]
  [""rds.syncrep_query_cancels"",""off""]
  [""rds.temp_tablespaces"",""rds_temp_tablespace""]
  [""rds.wal_allocator_max_size"",""192""]
  [""rds.walreceiver_send_archived_lsn_interval"",""5""]
  [""recovery_end_command"",null]
  [""recovery_min_apply_delay"",""0""]
  [""restart_after_crash"",""on""]
  [""ssl"",""on""]
  [""ssl_ca_file"",""/rdsdbdata/rds-metadata/ca-cert.pem""]
  [""ssl_cert_file"",""/rdsdbdata/rds-metadata/server-cert.pem""]
  [""ssl_ciphers"",""HIGH:!aNULL:!3DES""]
  [""ssl_crl_file"",null]
  [""ssl_dh_params_file"",null]
  [""ssl_ecdh_curve"",""prime256v1""]
  [""ssl_key_file"",""/rdsdbdata/rds-metadata/server-key.pem""]
  [""ssl_max_protocol_version"",null]
  [""ssl_min_protocol_version"",""TLSv1.2""]
  [""ssl_passphrase_command"",null]
  [""ssl_passphrase_command_supports_reload"",""off""]
  [""ssl_prefer_server_ciphers"",""on""]
  [""stats_temp_directory"",""/rdsdbdata/db/pg_stat_tmp""]
  [""synchronous_standby_names"",null]
  [""syslog_facility"",""local0""]
  [""syslog_ident"",""postgres""]
  [""syslog_sequence_numbers"",""on""]
  [""syslog_split_messages"",""on""]
  [""trace_recovery_messages"",""log""]
  [""vacuum_defer_cleanup_age"",""0""]
  [""wal_keep_size"",""2048""]
  [""wal_receiver_create_temp_slot"",""off""]
  [""wal_receiver_status_interval"",""10""]
  [""wal_receiver_timeout"",""30000""]
  [""wal_retrieve_retry_interval"",""5000""]
  [""wal_sync_method"",""fdatasync""]
  [""wal_writer_delay"",""200""]
  [""wal_writer_flush_after"",""128""]","Restore all values in the PostgreSQL configuration files and invoke the server to reload the configuration files.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.5 Ensure 'Superuser' Runtime Parameters are Configured"" : [WARNING]

PostgreSQL runtime parameters that can only be executed by the server's superuser, postgres.

Rationale:

In order to improve and optimize server performance, the server's superuser has the privilege of setting these parameters which are found in the configuration file postgresql.conf. Alternatively, they can be changed in a PostgreSQL login session via the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files. A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
The exploit is made in the configuration files. These changes are effected upon server restart. Once detected, the unauthorized/undesired change can be made by editing the altered configuration file and executing a server restart. In the case where the parameter has been set on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:

Query the view pg_settings and compare with previous query outputs for any changes.

Review the configuration files postgreql.conf and postgreql.auto.conf and compare with previously archived file copies for any changes

Examine the process output and look for parameters that were used at server startup:

ps aux | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context = 'superuser' order by 1
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/postgres:
  [""allow_in_place_tablespaces"",""off""]
  [""backtrace_functions"",null]
  [""dynamic_library_path"",""$libdir""]
  [""ignore_checksum_failure"",""off""]
  [""jit_dump_bitcode"",""off""]
  [""local_preload_libraries"",null]
  [""lo_compat_privileges"",""off""]
  [""log_parameter_max_length"",""-1""]
  [""max_stack_depth"",""6144""]
  [""rds.extensions"",""address_standardizer, address_standardizer_data_us, amcheck, autoinc, aws_commons, aws_lambda, aws_s3, bloom, bool_plperl, btree_gin, btree_gist, citext, cube, dblink, dict_int, dict_xsyn, earthdistance, flow_control, fuzzystrmatch, h3, h3_postgis, hll, hstore, hstore_plperl, hypopg, insert_username, intagg, intarray, ip4r, isn, jsonb_plperl, lo, log_fdw, ltree, moddatetime, mysql_fdw, oracle_fdw, orafce, pageinspect, pgactive, pgaudit, pgcrypto, pglogical, pgrouting, pgrowlocks, pgstattuple, pgtap, pg_bigm, pg_buffercache, pg_cron, pg_freespacemap, pg_hint_plan, pg_partman, pg_prewarm, pg_proctab, pg_repack, pg_similarity, pg_stat_statements, pg_tle, pg_transport, pg_trgm, pg_visibility, plcoffee, plls, plperl, plpgsql, plprofiler, plrust, pltcl, plv8, postgis, postgis_raster, postgis_tiger_geocoder, postgis_topology, postgres_fdw, prefix, rdkit, rds_tools, refint, seg, sslinfo, tablefunc, tcn, tds_fdw, test_parser, tsm_system_rows, tsm_system_time, unaccent, uuid-ossp, vector""]
  [""rds.superuser_variables"",""session_replication_role""]
  [""session_preload_libraries"",null]
  [""update_process_title"",""on""]
  [""wal_compression"",""on""]
  [""wal_consistency_checking"",null]
  [""wal_init_zero"",""on""]
  [""wal_recycle"",""on""]
  [""zero_damaged_pages"",""off""]","The exploit is made in the configuration files. These changes are effected upon server restart. Once detected, the unauthorized/undesired change can be made by editing the altered configuration file and executing a server restart. In the case where the parameter has been set on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:

Query the view pg_settings and compare with previous query outputs for any changes.

Review the configuration files postgreql.conf and postgreql.auto.conf and compare with previously archived file copies for any changes

Examine the process output and look for parameters that were used at server startup:

ps aux | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.6 Ensure 'User' Runtime Parameters are Configured"" : [WARNING]

These PostgreSQL runtime parameters are managed at the user account (ROLE) level.

Rationale:

In order to improve performance and optimize features, a ROLE has the privilege of setting numerous parameters in a transaction, session, or entity attribute. Any ROLE can alter any of these parameters.

Impact:

A denial of service is possible by the over-allocating of limited resources, such as RAM. Changing VACUUM parameters can force a server shutdown which is standard procedure preventing data corruption from transaction ID wraparound. Data can be corrupted by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Logging can be altered and obfuscated to inhibit root cause analysis.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
In the matter of a user session, the login sessions must be validated that it is not executing undesired parameter changes. In the matter of attributes that have been changed in entities, they must be manually reverted to their default value(s).

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context = 'user' order by 1
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/postgres:
  [""application_name"",null]
  [""array_nulls"",""on""]
  [""backend_flush_after"",""0""]
  [""backslash_quote"",""safe_encoding""]
  [""bytea_output"",""hex""]
  [""check_function_bodies"",""on""]
  [""client_encoding"",""UTF8""]
  [""client_min_messages"",""notice""]
  [""commit_siblings"",""5""]
  [""constraint_exclusion"",""partition""]
  [""cpu_index_tuple_cost"",""0.005""]
  [""cpu_operator_cost"",""0.0025""]
  [""cpu_tuple_cost"",""0.01""]
  [""cursor_tuple_fraction"",""0.1""]
  [""DateStyle"",""ISO, MDY""]
  [""debug_pretty_print"",""on""]
  [""debug_print_parse"",""off""]
  [""debug_print_plan"",""off""]
  [""debug_print_rewritten"",""off""]
  [""default_statistics_target"",""100""]
  [""default_table_access_method"",""heap""]
  [""default_tablespace"",null]
  [""default_text_search_config"",""pg_catalog.simple""]
  [""default_transaction_deferrable"",""off""]
  [""default_transaction_isolation"",""read committed""]
  [""default_transaction_read_only"",""off""]
  [""effective_cache_size"",""994031""]
  [""effective_io_concurrency"",""1""]
  [""enable_bitmapscan"",""on""]
  [""enable_gathermerge"",""on""]
  [""enable_hashagg"",""on""]
  [""enable_hashjoin"",""on""]
  [""enable_incremental_sort"",""on""]
  [""enable_indexonlyscan"",""on""]
  [""enable_indexscan"",""on""]
  [""enable_material"",""on""]
  [""enable_mergejoin"",""on""]
  [""enable_nestloop"",""on""]
  [""enable_parallel_append"",""on""]
  [""enable_parallel_hash"",""on""]
  [""enable_partition_pruning"",""on""]
  [""enable_partitionwise_aggregate"",""off""]
  [""enable_partitionwise_join"",""off""]
  [""enable_seqscan"",""on""]
  [""enable_sort"",""on""]
  [""enable_tidscan"",""on""]
  [""escape_string_warning"",""on""]
  [""exit_on_error"",""off""]
  [""extra_float_digits"",""1""]
  [""force_parallel_mode"",""off""]
  [""from_collapse_limit"",""8""]
  [""geqo"",""on""]
  [""geqo_effort"",""5""]
  [""geqo_generations"",""0""]
  [""geqo_pool_size"",""0""]
  [""geqo_seed"",""0""]
  [""geqo_selection_bias"",""2""]
  [""geqo_threshold"",""12""]
  [""gin_fuzzy_search_limit"",""0""]
  [""gin_pending_list_limit"",""4096""]
  [""hash_mem_multiplier"",""1""]
  [""idle_in_transaction_session_timeout"",""86400000""]
  [""IntervalStyle"",""postgres""]
  [""jit"",""off""]
  [""jit_above_cost"",""100000""]
  [""jit_expressions"",""on""]
  [""jit_inline_above_cost"",""500000""]
  [""jit_optimize_above_cost"",""500000""]
  [""jit_tuple_deforming"",""on""]
  [""join_collapse_limit"",""8""]
  [""lc_monetary"",""C""]
  [""lc_numeric"",""C""]
  [""lc_time"",""C""]
  [""lock_timeout"",""0""]
  [""logical_decoding_work_mem"",""65536""]
  [""log_parameter_max_length_on_error"",""0""]
  [""maintenance_io_concurrency"",""10""]
  [""maintenance_work_mem"",""260729""]
  [""max_parallel_maintenance_workers"",""2""]
  [""max_parallel_workers"",""8""]
  [""max_parallel_workers_per_gather"",""2""]
  [""min_parallel_index_scan_size"",""64""]
  [""min_parallel_table_scan_size"",""1024""]
  [""operator_precedence_warning"",""off""]
  [""parallel_leader_participation"",""on""]
  [""parallel_setup_cost"",""1000""]
  [""parallel_tuple_cost"",""0.1""]
  [""password_encryption"",""scram-sha-256""]
  [""plan_cache_mode"",""auto""]
  [""quote_all_identifiers"",""off""]
  [""random_page_cost"",""4""]
  [""row_security"",""on""]
  [""search_path"",""\""$user\"", public""]
  [""seq_page_cost"",""1""]
  [""standard_conforming_strings"",""on""]
  [""statement_timeout"",""0""]
  [""synchronize_seqscans"",""on""]
  [""synchronous_commit"",""on""]
  [""tcp_keepalives_count"",""2""]
  [""tcp_keepalives_idle"",""300""]
  [""tcp_keepalives_interval"",""30""]
  [""tcp_user_timeout"",""0""]
  [""temp_buffers"",""1024""]
  [""temp_tablespaces"",null]
  [""TimeZone"",""UTC""]
  [""timezone_abbreviations"",""Default""]
  [""trace_notify"",""off""]
  [""trace_sort"",""off""]
  [""transaction_deferrable"",""off""]
  [""transaction_isolation"",""read committed""]
  [""transaction_read_only"",""off""]
  [""transform_null_equals"",""off""]
  [""vacuum_cleanup_index_scale_factor"",""0.1""]
  [""vacuum_cost_delay"",""0""]
  [""vacuum_cost_limit"",""1500""]
  [""vacuum_cost_page_dirty"",""20""]
  [""vacuum_cost_page_hit"",""1""]
  [""vacuum_cost_page_miss"",""5""]
  [""vacuum_freeze_min_age"",""50000000""]
  [""vacuum_freeze_table_age"",""150000000""]
  [""vacuum_multixact_freeze_min_age"",""5000000""]
  [""vacuum_multixact_freeze_table_age"",""150000000""]
  [""wal_sender_timeout"",""30000""]
  [""wal_skip_threshold"",""2048""]
  [""work_mem"",""12288""]
  [""xmlbinary"",""base64""]
  [""xmloption"",""content""]","In the matter of a user session, the login sessions must be validated that it is not executing undesired parameter changes. In the matter of attributes that have been changed in entities, they must be manually reverted to their default value(s).","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.8 Ensure TLS is enabled and configured correctly"" : [PASSED]

TLS on a PostgreSQL server should be enabled and configured to encrypt TCP traffic to and from the server.

Rationale:

If TLS is not enabled and configured correctly, this increases the risk of data being compromised in transit.

Impact:

A self-signed certificate can be used for testing, but a certificate signed by a certificate authority (CA) (either one of the global CAs or a local one) should be used in production so that clients can verify the server's identity. If all the database clients are local to the organization, using a local CA is recommended.

To ultimately enable and enforce TLS authentication for the server, appropriate hostssl records must be added to the pg_hba.conf file. Be sure to reload PostgreSQL after any changes (restart not required).

Note: The hostssl record matches connection attempts made using TCP/IP, but only when the connection is made with TLS encryption. The host record matches attempts made using TCP/IP, but allows both TLS and non-TLS connections. The hostnossl record matches attempts made using TCP/IP, but only those without TLS. Care should be taken to enforce TLS as appropriate.

Solution:
For this example, and ease of illustration, we will be using a self-signed certificate (generated via openssl) for the server, and the PostgreSQL defaults for file naming and location in the PostgreSQL $PGDATA directory.

# whoami
postgres
# # create new certificate and enter details at prompts
# openssl req -new -newkey rsa:4096 -text -out server.req
Generating a 4096 bit RSA private key
.....................+++
..................................................................+++
writing new private key to 'privkey.pem'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:US
State or Province Name (full name) []:Ohio
Locality Name (eg, city) [Default City]:Columbus
Organization Name (eg, company) [Default Company Ltd]:Me Inc
Organizational Unit Name (eg, section) []:IT
Common Name (eg, your name or your server's hostname) []:my.me.inc
Email Address []:me@meinc.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:

# # remove passphrase (required for automatic server start up, if not using 'ssl_passphrase_command')
# openssl rsa -in privkey.pem -out server.key && rm privkey.pem
Enter pass phrase for privkey.pem:
writing RSA key

# # modify certificate to self signed, generate .key and .crt files
# openssl req -x509 -in server.req -text -key server.key -out server.crt

# # copy .key and .crt files to appropriate location, here default $PGDATA
$ cp server.key server.crt $PGDATA

# # restrict file mode for server.key
$ chmod og-rwx server.key

Edit the PostgreSQL configuration file postgresql.conf to ensure the following items are set. Again, we are using defaults. Note that altering these parameters will require restarting the cluster.

# (change requires restart)
ssl = on

# force clients to use TLS v1.3 or newer
ssl_min_protocol_version = 'TLSv1.3'

# (change requires restart)
ssl_cert_file = 'server.crt'

# (change requires restart)
ssl_key_file = 'server.key'

Finally, restart PostgreSQL and confirm ssl using commands outlined in Audit Procedures:

postgres=# show ssl;
 ssl
-----
 on
(1 row)

Default Value:

Note that server.crt and server.key are the default names used by PostgreSQL. These files can be named otherwise, just ensure you update the postgresql.conf to use these new names. The current names can be found via SQL:

postgres=# select name, setting from pg_settings where name like 'ssl%file';

|--------------------|------------|

|        name        |  setting   |

|--------------------|------------|

| ssl_ca_file        |            |

| ssl_cert_file      | server.crt |

| ssl_crl_file       |            |

| ssl_dh_params_file |            |

| ssl_key_file       | server.key |

|--------------------|------------|

(5 rows)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1A,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1

Policy Value:
SQL_POLICY
sql_request: show ssl
sql_expect: STRING - on

Actual Value:
5432/postgres:
* [""on""]","For this example, and ease of illustration, we will be using a self-signed certificate (generated via openssl) for the server, and the PostgreSQL defaults for file naming and location in the PostgreSQL $PGDATA directory.

# whoami
postgres
# # create new certificate and enter details at prompts
# openssl req -new -newkey rsa:4096 -text -out server.req
Generating a 4096 bit RSA private key
.....................+++
..................................................................+++
writing new private key to 'privkey.pem'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:US
State or Province Name (full name) []:Ohio
Locality Name (eg, city) [Default City]:Columbus
Organization Name (eg, company) [Default Company Ltd]:Me Inc
Organizational Unit Name (eg, section) []:IT
Common Name (eg, your name or your server's hostname) []:my.me.inc
Email Address []:me@meinc.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:

# # remove passphrase (required for automatic server start up, if not using 'ssl_passphrase_command')
# openssl rsa -in privkey.pem -out server.key && rm privkey.pem
Enter pass phrase for privkey.pem:
writing RSA key

# # modify certificate to self signed, generate .key and .crt files
# openssl req -x509 -in server.req -text -key server.key -out server.crt

# # copy .key and .crt files to appropriate location, here default $PGDATA
$ cp server.key server.crt $PGDATA

# # restrict file mode for server.key
$ chmod og-rwx server.key

Edit the PostgreSQL configuration file postgresql.conf to ensure the following items are set. Again, we are using defaults. Note that altering these parameters will require restarting the cluster.

# (change requires restart)
ssl = on

# force clients to use TLS v1.3 or newer
ssl_min_protocol_version = 'TLSv1.3'

# (change requires restart)
ssl_cert_file = 'server.crt'

# (change requires restart)
ssl_key_file = 'server.key'

Finally, restart PostgreSQL and confirm ssl using commands outlined in Audit Procedures:

postgres=# show ssl;
 ssl
-----
 on
(1 row)

Default Value:

Note that server.crt and server.key are the default names used by PostgreSQL. These files can be named otherwise, just ensure you update the postgresql.conf to use these new names. The current names can be found via SQL:

postgres=# select name, setting from pg_settings where name like 'ssl%file';

|--------------------|------------|

|        name        |  setting   |

|--------------------|------------|

| ssl_ca_file        |            |

| ssl_cert_file      | server.crt |

| ssl_crl_file       |            |

| ssl_dh_params_file |            |

| ssl_key_file       | server.key |

|--------------------|------------|

(5 rows)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.9 Ensure the pgcrypto extension is installed and configured correctly"" : [FAILED]

PostgreSQL must implement cryptographic mechanisms to prevent unauthorized disclosure or modification of organization-defined information at rest (to include, at a minimum, PII and classified information) on organization-defined information system components.

Rationale:

PostgreSQL instances handling data that requires 'data at rest' protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to PostgreSQL or implemented via additional software or operating system/file system settings, as appropriate to the situation. Information at rest refers to the state of information when it is located on a secondary storage device (e.g. disk drive, tape drive) within an organizational information system.

The selection of a cryptographic mechanism is based on the need to protect the integrity of organizational information. The strength of the mechanism is commensurate with the security category and/or classification of the information. Organizations have the flexibility to either encrypt all information on storage devices (i.e. full disk encryption) or encrypt specific data structures (e.g. files, records, or fields). Organizations may also optionally choose to implement both to implement layered security.

The decision of whether, and what, to encrypt rests with the data owner and is also influenced by the physical measures taken to secure the equipment and media on which the information resides. Organizations may choose to employ different mechanisms to achieve confidentiality and integrity protection, as appropriate. If the confidentiality and integrity of application data are not protected, the data will be open to compromise and unauthorized modification.

The PostgreSQL pgcrypto extension provides cryptographic functions for PostgreSQL and is intended to address the confidentiality and integrity of user and system information at rest in non-mobile devices.

Impact:

When considering or undertaking any form of encryption, it is critical to understand the state of the encrypted data at all stages of the data lifecycle. The use of pgcrypto ensures that the data at rest in the tables (and therefore on disk) is encrypted, but for the data to be accessed by any users or applications, said users/applications will, by necessity, have access to the encrypt and decrypt keys and the data in question will be encrypted/decrypted in memory and then transferred to/from the user/application in that form.

Solution:
The pgcrypto extension is included with the PostgreSQL 'contrib' package. Although included, it needs to be created in the database.

As the database administrator, run the following:

postgres=# CREATE EXTENSION pgcrypto;
CREATE EXTENSION

Verify pgcrypto is installed:

postgres=# SELECT * FROM pg_available_extensions WHERE name='pgcrypto';
   name   | default_version | installed_version |         comment
----------+-----------------+-------------------+-------------------------
 pgcrypto | 1.3             | 1.3               | cryptographic functions
(1 row)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|1M,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1

Policy Value:
SQL_POLICY
sql_request: SELECT * FROM pg_available_extensions where name='pgcrypto'
sql_expect: STRING - pgcrypto
sql_expect: REGEX - .*
sql_expect: REGEX - .*
sql_expect: REGEX - .*

Actual Value:
5432/postgres:
  [""pgcrypto"",""1.3"",null,""cryptographic functions""]","The pgcrypto extension is included with the PostgreSQL 'contrib' package. Although included, it needs to be created in the database.

As the database administrator, run the following:

postgres=# CREATE EXTENSION pgcrypto;
CREATE EXTENSION

Verify pgcrypto is installed:

postgres=# SELECT * FROM pg_available_extensions WHERE name='pgcrypto';
   name   | default_version | installed_version |         comment
----------+-----------------+-------------------+-------------------------
 pgcrypto | 1.3             | 1.3               | cryptographic functions
(1 row)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.1 Ensure a replication-only user is created and used for streaming replication"" : [WARNING]

Create a new user specifically for use by streaming replication instead of using the superuser account.

Rationale:

As it is not necessary to be a superuser to initiate a replication connection, it is proper to create an account specifically for replication. This allows further 'locking down' the uses of the superuser account and follows the general principle of using the least privileges necessary.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
It will be necessary to create a new role for replication purposes:

postgres=# create user replication_user REPLICATION encrypted password 'XXX';
CREATE ROLE
postgres=# select rolname from pg_roles where rolreplication is true;
     rolname
------------------
 postgres
 replication_user
(2 rows)

When using pg_basebackup (or other replication tools) on your standby server, you would use the replication_user (and its password).

Ensure you allow the new user via your pg_hba.conf file:

# note that 'replication' in the 2nd column is required and is a special
# keyword, not a real database
hostssl replication     replication_user    0.0.0.0/0         scram-sha-256

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
SQL_POLICY
sql_request: select rolname from pg_roles where rolreplication is true;
sql_expect: STRING - rolname

Actual Value:
5432/postgres:
  [""rdsrepladmin""]
  [""rdsadmin""]","It will be necessary to create a new role for replication purposes:

postgres=# create user replication_user REPLICATION encrypted password 'XXX';
CREATE ROLE
postgres=# select rolname from pg_roles where rolreplication is true;
     rolname
------------------
 postgres
 replication_user
(2 rows)

When using pg_basebackup (or other replication tools) on your standby server, you would use the replication_user (and its password).

Ensure you allow the new user via your pg_hba.conf file:

# note that 'replication' in the 2nd column is required and is a special
# keyword, not a real database
hostssl replication     replication_user    0.0.0.0/0         scram-sha-256","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.2 Ensure logging of replication commands is configured"" : [PASSED]

Enabling the log_replication_commands setting causes each attempted replication from the server to be logged.

Rationale:

A successful replication connection allows for a complete copy of the data stored within the data cluster to be offloaded to another, potentially insecure, host. As such, it is advisable to log all replication commands that are executed in your database cluster to ensure the data is not off-loaded to an unexpected/undesired location.

Solution:
To enable the logging of replication commands, execute the following:

postgres=# ALTER SYSTEM SET log_replication_commands = 'on';
ALTER SYSTEM
postgres=# SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_replication_commands ;
 log_replication_commands
--------------------------
 on
(1 row)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
SQL_POLICY
sql_request: show log_replication_commands;
sql_expect: STRING - off

Actual Value:
5432/postgres:
* [""off""]","To enable the logging of replication commands, execute the following:

postgres=# ALTER SYSTEM SET log_replication_commands = 'on';
ALTER SYSTEM
postgres=# SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_replication_commands ;
 log_replication_commands
--------------------------
 on
(1 row)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.3 Ensure base backups are configured and functional"" : [WARNING]

A 'base backup' is a copy of the PRIMARY host's data cluster ($PGDATA) and is used to create STANDBY hosts and for Point In Time Recovery (PITR) mechanisms. Base backups should be copied across networks in a secure manner using an encrypted transport mechanism. The PostgreSQL CLI pg_basebackup can be used, however, TLS encryption should be enabled on the server as per section 6.8 of this benchmark. The pgBackRest tool detailed in section 8.3 of this benchmark can also be used to create a 'base backup'.

Rationale:

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
Executing base backups using pg_basebackup requires the following steps on the standby server:

$ whoami
postgres
$ pg_basebackup --host=name_or_IP_of_master \
--port=5432 \
--username=replication_user \
--pgdata=~postgres/13/data \
--progress --verbose --write-recovery-conf --wal-method=stream

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.8.9,800-53|CP-4,800-53|CP-9(1),800-53r5|CP-4,800-53r5|CP-9(1),CSCv7|10.3,CSCv8|11.5,CSF|PR.IP-4,CSF|PR.IP-10,GDPR|32.1.b,GDPR|32.1.c,HIPAA|164.306(a)(1),ISO/IEC-27001|A.12.3.1,ITSG-33|CP-4,ITSG-33|CP-9(1),LEVEL|1M,NESA|T2.2.4,NESA|T3.5.1,QCSC-v1|10.2.1,QCSC-v1|11.2

Policy Value:
WARNING

Actual Value:
5432/postgres:
WARNING","Executing base backups using pg_basebackup requires the following steps on the standby server:

$ whoami
postgres
$ pg_basebackup --host=name_or_IP_of_master \
--port=5432 \
--username=replication_user \
--pgdata=~postgres/13/data \
--progress --verbose --write-recovery-conf --wal-method=stream","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.4 Ensure WAL archiving is configured and functional - archive_mode"" : [PASSED]

Write Ahead Log (WAL) Archiving, or Log Shipping, is the process of sending transaction log files from the PRIMARY host either to one or more STANDBY hosts or to be archived on a remote storage device for later use, e.g. PITR. There are several utilities that can copy WALs including, but not limited to, cp, scp, sftp, and rynsc. Basically, the server follows a set of runtime parameters which define when the WAL should be copied using one of the aforementioned utilities.

Rationale:

Unless the server has been correctly configured, one runs the risk of sending WALs in an unsecured, unencrypted fashion.

Solution:
Change parameters and restart the server as required.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1A,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where name ~ '^archive' ORDER BY 1;
sql_expect: STRING - archive_mode
sql_expect: STRING - on
match_all: NO

Actual Value:
5432/postgres:
  [""archive_cleanup_command"",null]
  [""archive_command"",""/etc/rds/dbbin/pgscripts/rds_wal_archive %p skipTimeCheckForWalSegmentAndReadyFile""]
* [""archive_mode"",""on""]
  [""archive_timeout"",""300""]","Change parameters and restart the server as required.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.4 Ensure WAL archiving is configured and functional - archive_command"" : [FAILED]

Write Ahead Log (WAL) Archiving, or Log Shipping, is the process of sending transaction log files from the PRIMARY host either to one or more STANDBY hosts or to be archived on a remote storage device for later use, e.g. PITR. There are several utilities that can copy WALs including, but not limited to, cp, scp, sftp, and rynsc. Basically, the server follows a set of runtime parameters which define when the WAL should be copied using one of the aforementioned utilities.

Rationale:

Unless the server has been correctly configured, one runs the risk of sending WALs in an unsecured, unencrypted fashion.

Solution:
Change parameters and restart the server as required.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1A,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where name ~ '^archive' ORDER BY 1;
sql_expect: STRING - archive_command
sql_expect: STRING - \'.*ssh
match_all: NO

Actual Value:
5432/postgres:
  [""archive_cleanup_command"",null]
  [""archive_command"",""/etc/rds/dbbin/pgscripts/rds_wal_archive %p skipTimeCheckForWalSegmentAndReadyFile""]
  [""archive_mode"",""on""]
  [""archive_timeout"",""300""]","Change parameters and restart the server as required.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.5 Ensure streaming replication parameters are configured correctly"" : [WARNING]

Streaming replication from a PRIMARY host transmits DDL, DML, passwords, and other potentially sensitive activities and data. These connections should be protected with Secure Sockets Layer (SSL).

Rationale:

Unencrypted transmissions could reveal sensitive information to unauthorized parties. Unauthenticated connections could enable man-in-the-middle attacks.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
Review prior sections in this benchmark regarding TLS certificates, replication user, and WAL archiving.

Confirm the file $PGDATA/standby.signal is present on the STANDBY host and $PGDATA/postgresql.auto.conf contains lines similar to the following:

primary_conninfo = 'user=replication_user password=mypassword host=mySrcHost port=5432 sslmode=require sslcompression=1'

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1

Policy Value:
WARNING

Actual Value:
5432/postgres:
WARNING","Review prior sections in this benchmark regarding TLS certificates, replication user, and WAL archiving.

Confirm the file $PGDATA/standby.signal is present on the STANDBY host and $PGDATA/postgresql.auto.conf contains lines similar to the following:

primary_conninfo = 'user=replication_user password=mypassword host=mySrcHost port=5432 sslmode=require sslcompression=1'","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""8.1 Ensure PostgreSQL subdirectory locations are outside the data cluster"" : [WARNING]

The PostgreSQL cluster is organized to carry out specific tasks in subdirectories. For the purposes of performance, reliability, and security some of these subdirectories should be relocated outside the data cluster.

Rationale:

Some subdirectories contain information, such as logs, which can be of value to others such as developers. Other subdirectories can gain a performance benefit when placed on fast storage devices. Other subdirectories contain temporary files created and used during processing. Finally, relocating a subdirectory to a separate and distinct partition mitigates denial of service and involuntary server shutdown when excessive writes fill the data cluster's partition, e.g. pg_wal, pg_log, and temp_tablespaces.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Perform the following steps to remediate the subdirectory locations and permissions:

Determine appropriate data, log, and tablespace directories and locations based on your organization's security policies. If necessary, relocate all listed directories outside the data cluster.

If not relocating temp_tablespaces, the temp_file_limit parameter must be changed from its default value.

Ensure file permissions are restricted as much as possible, i.e. only superuser read access.

When directories are relocated to other partitions, ensure that they are of sufficient size to mitigate against excessive space utilization.

Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.

To relocate temp_tablespaces to an existing mount point outside the data cluster is accomplished by:

postgres=# CREATE TABLESPACE temp_tablespc LOCATION '/path/to/existing/desired/mount/point';
postgres=# ALTER SYSTEM SET temp_tablespaces = 'temp_tablespc';
postgres=# SELECT pg_reload_conf();

Default Value:

The default for data_directory is ConfigDir and the default for log_directory is log (based on the absolute path of data_directory). The defaults for tablespace settings are null, or not set, upon cluster creation.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where (name ~ '_directory$' or name ~ '_tablespace')
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/postgres:
  [""allow_in_place_tablespaces"",""off""]
  [""data_directory"",""/rdsdbdata/db""]
  [""default_tablespace"",null]
  [""log_directory"",""/rdsdbdata/log/error""]
  [""rds.temp_tablespaces"",""rds_temp_tablespace""]
  [""stats_temp_directory"",""/rdsdbdata/db/pg_stat_tmp""]
  [""temp_tablespaces"",null]","Perform the following steps to remediate the subdirectory locations and permissions:

Determine appropriate data, log, and tablespace directories and locations based on your organization's security policies. If necessary, relocate all listed directories outside the data cluster.

If not relocating temp_tablespaces, the temp_file_limit parameter must be changed from its default value.

Ensure file permissions are restricted as much as possible, i.e. only superuser read access.

When directories are relocated to other partitions, ensure that they are of sufficient size to mitigate against excessive space utilization.

Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.

To relocate temp_tablespaces to an existing mount point outside the data cluster is accomplished by:

postgres=# CREATE TABLESPACE temp_tablespc LOCATION '/path/to/existing/desired/mount/point';
postgres=# ALTER SYSTEM SET temp_tablespaces = 'temp_tablespc';
postgres=# SELECT pg_reload_conf();

Default Value:

The default for data_directory is ConfigDir and the default for log_directory is log (based on the absolute path of data_directory). The defaults for tablespace settings are null, or not set, upon cluster creation.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""8.3 Ensure miscellaneous configuration settings are correct"" : [WARNING]

This recommendation covers non-regular, special files, and dynamic libraries.

PostgreSQL permits local logins via the UNIX DOMAIN SOCKET and, for the most part, anyone with a legitimate Unix login account can make the attempt. Limiting PostgreSQL login attempts can be made by relocating the UNIX DOMAIN SOCKET to a subdirectory with restricted permissions.

The creation and implementation of user-defined dynamic libraries is an extraordinary powerful capability. In the hands of an experienced DBA/programmer, it can significantly enhance the power and flexibility of the RDBMS; but new and unexpected behavior can also be assigned to the RDBMS, resulting in a very dangerous environment in what should otherwise be trusted.

Rationale:

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Follow these steps to remediate the configuration:

Determine permissions based on your organization's security policies.

Relocate all files and ensure their permissions are restricted as much as possible, i.e. only superuser read access.

Ensure all directories where these files are located have restricted permissions such that the superuser can read but not write.

Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.

Default Value:

The dynamic_library_path default is $libdir and unix_socket_directories default is /var/run/postgresql, /tmp. The default for external_pid_file and all library parameters are initially null, or not set, upon cluster creation.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: SELECT name, setting FROM pg_settings WHERE name IN ('external_pid_file' ,'unix_socket_directories' ,'shared_preload_libraries' ,'dynamic_library_path' ,'local_preload_libraries' ,'session_preload_libraries' )
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/postgres:
  [""dynamic_library_path"",""$libdir""]
  [""external_pid_file"",null]
  [""local_preload_libraries"",null]
  [""session_preload_libraries"",null]
  [""shared_preload_libraries"",""rdsutils,pg_stat_statements""]
  [""unix_socket_directories"",""/tmp""]","Follow these steps to remediate the configuration:

Determine permissions based on your organization's security policies.

Relocate all files and ensure their permissions are restricted as much as possible, i.e. only superuser read access.

Ensure all directories where these files are located have restricted permissions such that the superuser can read but not write.

Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.

Default Value:

The dynamic_library_path default is $libdir and unix_socket_directories default is /var/run/postgresql, /tmp. The default for external_pid_file and all library parameters are initially null, or not set, upon cluster creation.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/template0:
  ERROR: unable to login: [M: database ""template0"" is not currently accepting connections]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""CIS_PostgreSQL_13_v1.1.0_L1_DB.audit from CIS PostgreSQL 13 Benchmark v1.1.0"" : [WARNING]

NOTE: Nessus has not identified that the chosen audit applies to the target device.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Policy Value:
WARNING

Actual Value:
5432/template0:
WARNING","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/template0:
  ERROR: unable to login: [M: database ""template0"" is not currently accepting connections]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""Compliance plugin error"" : [WARNING]

There was an error that prevented the compliance plugin from proceeding with evaluating the policy.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Error:
5432/template0:
  ERROR: unable to login: [M: database ""template0"" is not currently accepting connections]","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""CIS_PostgreSQL_13_v1.1.0_L1_DB.audit from CIS PostgreSQL 13 Benchmark v1.1.0"" : [PASSED]

See Also: https://workbench.cisecurity.org/benchmarks/11864

Policy Value:
PASSED

Actual Value:
5432/template1:
PASSED","n/a","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.2 Ensure the log destinations are set correctly"" : [PASSED]

PostgreSQL supports several methods for logging server messages, including stderr, csvlog, syslog, and jsonlog. On Windows, eventlog is also supported. One or more of these destinations should be set for server log output.

Rationale:

If log_destination is not set, then any log messages generated by the core PostgreSQL processes will be lost.

Solution:
Execute the following SQL statements to remediate this setting (in this example, setting the log destination to csvlog):

postgres=# alter system set log_destination = 'csvlog';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Note: If more than one log destination is to be used, set this parameter to a list of desired log destinations separated by commas (e.g. 'csvlog, stderr').

Default Value:

stderr

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_destination
sql_expect: STRING - stderr

Actual Value:
5432/template1:
* [""stderr""]","Execute the following SQL statements to remediate this setting (in this example, setting the log destination to csvlog):

postgres=# alter system set log_destination = 'csvlog';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Note: If more than one log destination is to be used, set this parameter to a list of desired log destinations separated by commas (e.g. 'csvlog, stderr').

Default Value:

stderr","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.3 Ensure the logging collector is enabled"" : [PASSED]

The logging collector is a background process that captures log messages sent to stderr and redirects them into log files. The logging_collector setting must be enabled in order for this process to run. It can only be set at the server start.

Rationale:

The logging collector approach is often more useful than logging to syslog, since some types of messages might not appear in syslog output. One common example is dynamic-linker failure message; another may be error messages produced by scripts such as archive_command.

Note: This setting must be enabled when log_destination is either stderr or csvlog or logs will be lost. Certain other logging parameters require it as well.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set logging_collector = 'on';
ALTER SYSTEM

Unfortunately, this setting can only be changed at the server (re)start. As root, restart the PostgreSQL service for this change to take effect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since <date>; <count>s ago

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show logging_collector
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""on""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set logging_collector = 'on';
ALTER SYSTEM

Unfortunately, this setting can only be changed at the server (re)start. As root, restart the PostgreSQL service for this change to take effect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since <date>; <count>s ago

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.4 Ensure the log file destination directory is set correctly"" : [PASSED]

The log_directory setting specifies the destination directory for log files when log_destination is stderr or csvlog. It can be specified as relative to the cluster data directory ($PGDATA) or as an absolute path. log_directory should be set according to your organization's logging policy.

Rationale:

If log_directory is not set, it is interpreted as the absolute path '/' and PostgreSQL will attempt to write its logs there (and typically fail due to a lack of permissions to that directory). This parameter should be set to direct the logs into the appropriate directory location as defined by your organization's logging policy.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_directory='/var/log/postgres';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_directory;
 log_directory
---------------
 /var/log/postgres
(1 row)

Note: The use of /var/log/postgres, above, is an example. This should be set to an appropriate path as defined by your organization's logging requirements. Having said that, it is a good idea to have the logs outside of your PGDATA directory so that they are not included by things like pg_basebackup or pgBackRest.

Default Value:

log which is relative to the cluster's data directory (e.g. /var/lib/pgsql/<pgmajorversion>/data/log)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_directory
sql_expect: STRING - /rdsdbdata/log/error

Actual Value:
5432/template1:
* [""/rdsdbdata/log/error""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_directory='/var/log/postgres';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_directory;
 log_directory
---------------
 /var/log/postgres
(1 row)

Note: The use of /var/log/postgres, above, is an example. This should be set to an appropriate path as defined by your organization's logging requirements. Having said that, it is a good idea to have the logs outside of your PGDATA directory so that they are not included by things like pg_basebackup or pgBackRest.

Default Value:

log which is relative to the cluster's data directory (e.g. /var/lib/pgsql/<pgmajorversion>/data/log)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.5 Ensure the filename pattern for log files is set correctly"" : [PASSED]

The log_filename setting specifies the filename pattern for log files. The value for log_filename should match your organization's logging policy.

The value is treated as a strftime pattern, so %-escapes can be used to specify time-varying file names. The supported %-escapes are similar to those listed in the Open Group's strftime specification. If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the partition that contains log_directory. If there are any time-zone-dependent %-escapes, the computation is done in the zone specified by log_timezone. Also, the system's strftime is not used directly, so platform-specific (nonstandard) extensions do not work.

If CSV-format output is enabled in log_destination, .csv will be appended to the log filename. (If log_filename ends in .log, the suffix is replaced instead.)

Rationale:

If log_filename is not set, then the value of log_directory is appended to an empty string and PostgreSQL will fail to start as it will try to write to a directory instead of a file.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_filename='postgresql-%Y%m%d.log';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_filename;
   log_filename
-------------------
 postgresql-%Y%m%d.log
(1 row)

Note: In this example, a new log file will be created for each day (e.g. postgresql-20200804.log)

Default Value:

The default is postgresql-%a.log, which creates a new log file for each day of the week (e.g. postgresql-Mon.log, postgresql-Tue.log).

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_filename
sql_expect: STRING - postgresql.log.%Y-%m-%d-%H

Actual Value:
5432/template1:
* [""postgresql.log.%Y-%m-%d-%H""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_filename='postgresql-%Y%m%d.log';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_filename;
   log_filename
-------------------
 postgresql-%Y%m%d.log
(1 row)

Note: In this example, a new log file will be created for each day (e.g. postgresql-20200804.log)

Default Value:

The default is postgresql-%a.log, which creates a new log file for each day of the week (e.g. postgresql-Mon.log, postgresql-Tue.log).","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.6 Ensure the log file permissions are set correctly"" : [FAILED]

The log_file_mode setting determines the file permissions for log files when logging_collector is enabled. The parameter value is expected to be a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format, the number must start with a 0 (zero).)

The permissions should be set to allow only the necessary access to authorized personnel. In most cases, the best setting is 0600, so that only the server owner can read or write the log files. The other commonly useful setting is 0640, allowing members of the owner's group to read the files, although to make use of that, you will need to either alter the log_directory setting to store the log files outside the cluster data directory or use PGSETUP_INITDB_OPTIONS='-k -g' when initializing the cluster.

Rationale:

Log files often contain sensitive data. Allowing unnecessary access to log files may inadvertently expose sensitive data to unauthorized personnel.

Solution:
Execute the following SQL statement(s) to remediate this setting (with the example assuming the desired value of 0600):

postgres=# alter system set log_file_mode = '0600';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_file_mode;
 log_file_mode
---------------
 0600
(1 row)

Default Value:

0600

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
SQL_POLICY
sql_request: show log_file_mode
sql_expect: STRING - 0600

Actual Value:
5432/template1:
  [""0644""]","Execute the following SQL statement(s) to remediate this setting (with the example assuming the desired value of 0600):

postgres=# alter system set log_file_mode = '0600';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_file_mode;
 log_file_mode
---------------
 0600
(1 row)

Default Value:

0600","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.7 Ensure 'log_truncate_on_rotation' is enabled"" : [FAILED]

Enabling the log_truncate_on_rotation setting when logging_collector is enabled causes PostgreSQL to truncate (overwrite) existing log files with the same name during log rotation instead of appending to them. For example, using this setting in combination with a log_filename setting value like postgresql-%H.log would result in generating 24 hourly log files and then cyclically overwriting them:

postgresql-00.log

postgresql-01.log

[...]

postgresql-23.log

Note: Truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation (see later in this benchmark for size-based rotation details).

Rationale:

If this setting is disabled, pre-existing log files will be appended to if log_filename is configured in such a way that static or recurring names are generated.

Enabling or disabling the truncation should only be decided when also considering the value of log_filename and log_rotation_age/log_rotation_size. Some examples to illustrate the interaction between these settings:

# truncation is moot, as each rotation gets a unique filename (postgresql-20180605.log)

log_truncate_on_rotation = on

log_filename = 'postgresql-%Y%m%d.log'

log_rotation_age = '1d'

log_rotation_size = 0

# truncation every hour, losing log data every hour until the date changes

log_truncate_on_rotation = on

log_filename = 'postgresql-%Y%m%d.log'

log_rotation_age = '1h'

log_rotation_size = 0

# no truncation if the date changed before generating 100M of log data, truncation otherwise

log_truncate_on_rotation = on

log_filename = 'postgresql-%Y%m%d.log'

log_rotation_age = '0'

log_rotation_size = '100M'

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_truncate_on_rotation = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_truncate_on_rotation;
 log_truncate_on_rotation
--------------------------
 on
(1 row)

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_truncate_on_rotation
sql_expect: STRING - on

Actual Value:
5432/template1:
  [""off""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_truncate_on_rotation = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_truncate_on_rotation;
 log_truncate_on_rotation
--------------------------
 on
(1 row)

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.8 Ensure the maximum log file lifetime is set correctly"" : [PASSED]

When logging_collector is enabled, the log_rotation_age parameter determines the maximum lifetime of an individual log file (depending on the value of log_filename). After this many minutes have elapsed, a new log file will be created via automatic log file rotation. Current best practices advise log rotation at least daily, but your organization's logging policy should dictate your rotation schedule.

Rationale:

Log rotation is a standard best practice for log management.

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, setting it to one hour):

postgres=# alter system set log_rotation_age='1h';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

1d (one day)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_rotation_age
sql_expect: STRING - 1h

Actual Value:
5432/template1:
* [""1h""]","Execute the following SQL statement(s) to remediate this setting (in this example, setting it to one hour):

postgres=# alter system set log_rotation_age='1h';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

1d (one day)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.9 Ensure the maximum log file size is set correctly"" : [PASSED]

The log_rotation_size setting determines the maximum size of an individual log file. Once the maximum size is reached, automatic log file rotation will occur.

Rationale:

If this is set to zero, the size-triggered creation of new log files is disabled. This will prevent automatic log file rotation when files become too large, which could put log data at increased risk of loss (unless age-based rotation is configured).

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, setting it to 1GB):

postgres=# alter system set log_rotation_size = '1GB';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

0

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_rotation_size
sql_expect: STRING - 10MB

Actual Value:
5432/template1:
* [""10MB""]","Execute the following SQL statement(s) to remediate this setting (in this example, setting it to 1GB):

postgres=# alter system set log_rotation_size = '1GB';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

0","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.10 Ensure the correct syslog facility is selected"" : [PASSED]

The syslog_facility setting specifies the syslog 'facility' to be used when logging to syslog is enabled. You can choose from any of the 'local' facilities:

LOCAL0

LOCAL1

LOCAL2

LOCAL3

LOCAL4

LOCAL5

LOCAL6

LOCAL7

Your organization's logging policy should dictate which facility to use based on the syslog daemon in use.

Rationale:

If not set to the appropriate facility, the PostgreSQL log messages may be intermingled with other applications' log messages, incorrectly routed, or potentially dropped (depending on your syslog configuration).

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, setting it to the LOCAL1 facility):

postgres=# alter system set syslog_facility = 'LOCAL1';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

LOCAL0

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1M,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show syslog_facility
sql_expect: STRING - local0

Actual Value:
5432/template1:
* [""local0""]","Execute the following SQL statement(s) to remediate this setting (in this example, setting it to the LOCAL1 facility):

postgres=# alter system set syslog_facility = 'LOCAL1';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

LOCAL0","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.11 Ensure syslog messages are not suppressed"" : [PASSED]

When logging to Syslog and syslog_sequence_numbers is on, then each message will be prefixed by an increasing sequence number (such as [2]).

Rationale:

Many modern Syslog implementations perform a log optimization and suppress repeated log entries while emitting '--- last message repeated N times ---'. In more modern Syslog implementations, repeated message suppression can be configured (for example, $RepeatedMsgReduction in rsyslog).

Impact:

If disabled, messages sent to Syslog could be suppressed and not logged. While a message is emitted stating that a given message was repeated and suppressed, the timestamp associated with these suppressed messages is lost, potentially damaging the recreation of an incident timeline.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set syslog_sequence_numbers = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show syslog_sequence_numbers
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""on""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set syslog_sequence_numbers = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.12 Ensure syslog messages are not lost due to size"" : [PASSED]

PostgreSQL log messages can exceed 1024 bytes, which is a typical size limit for traditional Syslog implementations. When syslog_split_messages is off, PostgreSQL server log messages are delivered to the Syslog service as is, and it is up to the Syslog service to cope with the potentially bulky messages. When syslog_split_messages is on, messages are split by lines, and long lines are split so that they will fit into 1024 bytes.

If syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.

Rationale:

Impact:

Depending on the Syslog server in use, log messages exceeding 1024 bytes may be lost or, potentially, cause the Syslog server processes to abort.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set syslog_split_messages = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show syslog_split_messages
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""on""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set syslog_split_messages = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.13 Ensure the program name for PostgreSQL syslog messages is correct"" : [PASSED]

The syslog_ident setting specifies the program name used to identify PostgreSQL messages in syslog logs. An example of a possible program name is postgres.

Rationale:

If this is not set correctly, it may be difficult or impossible to distinguish PostgreSQL messages from other messages in Syslog logs.

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, assuming a program name of proddb):

postgres=# alter system set syslog_ident = 'proddb';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show syslog_ident;
 syslog_ident
--------------
 proddb
(1 row)

Default Value:

postgres

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show syslog_ident
sql_expect: STRING - postgres

Actual Value:
5432/template1:
* [""postgres""]","Execute the following SQL statement(s) to remediate this setting (in this example, assuming a program name of proddb):

postgres=# alter system set syslog_ident = 'proddb';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show syslog_ident;
 syslog_ident
--------------
 proddb
(1 row)

Default Value:

postgres","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.14 Ensure the correct messages are written to the server log"" : [PASSED]

The log_min_messages setting specifies the message levels that are written to the server log. Each level includes all the levels that follow it. The lower the level (vertically, below), the fewer messages are logged.

Valid values are:

DEBUG5 <-- exceedingly chatty

DEBUG4

DEBUG3

DEBUG2

DEBUG1

INFO

NOTICE

WARNING <-- default

ERROR

LOG

FATAL

PANIC <-- practically mute

WARNING is considered the best practice unless indicated otherwise by your organization's logging policy.

Rationale:

If this is not set to the correct value, too many or too few messages may be written to the server log.

Solution:
Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to set it to warning):

postgres=# alter system set log_min_messages = 'warning';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

WARNING

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_min_messages
sql_expect: STRING - warning

Actual Value:
5432/template1:
* [""warning""]","Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to set it to warning):

postgres=# alter system set log_min_messages = 'warning';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

WARNING","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.15 Ensure the correct SQL statements generating errors are recorded"" : [PASSED]

The log_min_error_statement setting causes all SQL statements generating errors at or above the specified severity level to be recorded in the server log. Each level includes all the levels that follow it. The lower the level (vertically, below), the fewer messages are recorded. Valid values are:

DEBUG5 <-- exceedingly chatty

DEBUG4

DEBUG3

DEBUG2

DEBUG1

INFO

NOTICE

WARNING

ERROR <-- default

LOG

FATAL

PANIC <-- practically mute

ERROR is considered the best practice setting. Changes should only be made in accordance with your organization's logging policy.

Note: To effectively turn off logging of failing statements, set this parameter to PANIC.

Rationale:

If this is not set to the correct value, too many erring or too few erring SQL statements may be written to the server log.

Solution:
Execute the following SQL statement(s) as superuser to remediate this setting (in the example, to error):

postgres=# alter system set log_min_error_statement = 'error';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

ERROR

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2

Policy Value:
SQL_POLICY
sql_request: show log_min_error_statement
sql_expect: STRING - error

Actual Value:
5432/template1:
* [""error""]","Execute the following SQL statement(s) as superuser to remediate this setting (in the example, to error):

postgres=# alter system set log_min_error_statement = 'error';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

ERROR","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.16 Ensure 'debug_print_parse' is disabled - debug_print_parse is disabled"" : [PASSED]

The debug_print_parse setting enables printing the resulting parse tree for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.

Rationale:

Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set debug_print_parse='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: show debug_print_parse
sql_expect: STRING - off

Actual Value:
5432/template1:
* [""off""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set debug_print_parse='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.17 Ensure 'debug_print_rewritten' is disabled - debug_print_rewritten is disabled"" : [PASSED]

The debug_print_rewritten setting enables printing the query rewriter output for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.

Rationale:

Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.

Solution:
Execute the following SQL statement(s) to disable this setting:

postgres=# alter system set debug_print_rewritten = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: show debug_print_rewritten
sql_expect: STRING - off

Actual Value:
5432/template1:
* [""off""]","Execute the following SQL statement(s) to disable this setting:

postgres=# alter system set debug_print_rewritten = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.18 Ensure 'debug_print_plan' is disabled - debug_print_plan is disabled"" : [PASSED]

The debug_print_plan setting enables printing the execution plan for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.

Rationale:

Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.

Solution:
Execute the following SQL statement(s) to disable this setting:

postgres=# alter system set debug_print_plan = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: show debug_print_plan
sql_expect: STRING - off

Actual Value:
5432/template1:
* [""off""]","Execute the following SQL statement(s) to disable this setting:

postgres=# alter system set debug_print_plan = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.19 Ensure 'debug_pretty_print' is enabled - debug_pretty_print is enabled"" : [PASSED]

Enabling debug_pretty_print indents the messages produced by debug_print_parse, debug_print_rewritten, or debug_print_plan making them significantly easier to read.

Rationale:

If this setting is disabled, the 'compact' format is used instead, significantly reducing the readability of the DEBUG statement log messages.

Impact:

Be advised that the aforementioned DEBUG printing options are disabled, but if your organizational logging policy requires them to be on then this option comes into play.

Solution:
Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set debug_pretty_print = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show debug_pretty_print
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""on""]","Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set debug_pretty_print = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

on","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.20 Ensure 'log_connections' is enabled - log_connections is enabled"" : [PASSED]

Enabling the log_connections setting causes each attempted connection to the server to be logged, as well as successful completion of client authentication. This parameter cannot be changed after the session start.

Rationale:

PostgreSQL does not maintain an internal record of attempted connections to the database for later auditing. It is only by enabling the logging of these attempts that one can determine if unexpected attempts are being made.

Note that enabling this without also enabling log_disconnections provides little value. Generally, you would enable/disable the pair together.

Solution:
Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set log_connections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Then, in a new connection to the database, verify the change:

postgres=# show log_connections;
 log_connections
-----------------
 on
(1 row)

Note that you cannot verify this change in the same connection in which it was changed; a new connection is needed.

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_connections
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""on""]","Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set log_connections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Then, in a new connection to the database, verify the change:

postgres=# show log_connections;
 log_connections
-----------------
 on
(1 row)

Note that you cannot verify this change in the same connection in which it was changed; a new connection is needed.

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.21 Ensure 'log_disconnections' is enabled - log_disconnections is enabled"" : [PASSED]

Enabling the log_disconnections setting logs the end of each session, including session duration. This parameter cannot be changed after the session start.

Rationale:

PostgreSQL does not maintain the beginning or ending of a connection internally for later review. It is only by enabling the logging of these that one can examine connections for failed attempts, 'over long' duration, or other anomalies.

Note that enabling this without also enabling log_connections provides little value. Generally, you would enable/disable the pair together.

Solution:
Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set log_disconnections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_disconnections
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""on""]","Execute the following SQL statement(s) to enable this setting:

postgres=# alter system set log_disconnections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.22 Ensure 'log_error_verbosity' is set correctly - log_error_verbosity is set correctly"" : [PASSED]

The log_error_verbosity setting specifies the verbosity (amount of detail) of logged messages. Valid values are:

TERSE

DEFAULT

VERBOSE

with each containing the fields of the level above it as well as additional fields.

TERSE excludes the logging of DETAIL, HINT, QUERY, and CONTEXT error information.

VERBOSE output includes the SQLSTATE, error code, and the source code file name, function name, and line number that generated the error.

The appropriate value should be set based on your organization's logging policy.

Rationale:

If this is not set to the correct value, too many details or too few details may be logged.

Solution:
Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to verbose):

postgres=# alter system set log_error_verbosity = 'verbose';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

DEFAULT

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_error_verbosity
sql_expect: STRING - default

Actual Value:
5432/template1:
* [""default""]","Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to verbose):

postgres=# alter system set log_error_verbosity = 'verbose';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

DEFAULT","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.23 Ensure 'log_hostname' is set correctly - log_hostname is set correctly"" : [PASSED]

Enabling the log_hostname setting causes the hostname of the connecting host to be logged in addition to the host's IP address for connection log messages. Disabling the setting causes only the connecting host's IP address to be logged, and not the hostname. Unless your organization's logging policy requires hostname logging, it is best to disable this setting so as not to incur the overhead of DNS resolution for each statement that is logged.

Rationale:

Depending on your hostname resolution setup, enabling this setting might impose a non-negligible performance penalty. Additionally, the IP addresses that are logged can be resolved to their DNS names when reviewing the logs (unless dynamic hostnames are being used as part of your DHCP setup).

Solution:
Execute the following SQL statement(s) to remediate this setting (in this example, to off):

postgres=# alter system set log_hostname='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: show log_hostname
sql_expect: STRING - off

Actual Value:
5432/template1:
* [""off""]","Execute the following SQL statement(s) to remediate this setting (in this example, to off):

postgres=# alter system set log_hostname='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

off","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.24 Ensure 'log_line_prefix' is set correctly - log_line_prefix is set correctly"" : [PASSED]

The log_line_prefix setting specifies a printf-style string that is prefixed to each log line. If blank, no prefix is used. You should configure this as recommended by the pgBadger development team unless directed otherwise by your organization's logging policy.

% characters begin 'escape sequences' that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the logline. Some escapes are only recognized by session processes and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files.

Any of the following escape sequences can be used:

%a = application name

%u = user name

%d = database name

%r = remote host and port

%h = remote host

%b = backend type

%p = process ID

%P = process ID of parallel group leader

%t = timestamp without milliseconds

%m = timestamp with milliseconds

%n = timestamp with milliseconds (as a Unix epoch)

%Q = query ID (0 if none or not computed)

%i = command tag

%e = SQL state

%c = session ID

%l = session line number

%s = session start timestamp

%v = virtual transaction ID

%x = transaction ID (0 if none)

%q = stop here in non-session processes

%% = '%'

Rationale:

Properly setting log_line_prefix allows for adding additional information to each log entry (such as the user, or the database). Said information may then be of use in auditing or security reviews.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_line_prefix = '%m [%p]: [%l-1] db=%d,user=%u,app=%a,client=%h ';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

%m [%p]

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_line_prefix
sql_expect: STRING - %t:%r:%u@%d:[%p]:

Actual Value:
5432/template1:
* [""%t:%r:%u@%d:[%p]:""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_line_prefix = '%m [%p]: [%l-1] db=%d,user=%u,app=%a,client=%h ';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

%m [%p]","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.25 Ensure 'log_statement' is set correctly - log_statement is set correctly"" : [PASSED]

The log_statement setting specifies the types of SQL statements that are logged. Valid values are:

none (off)

ddl

mod

all (all statements)

It is recommended this be set to ddl unless otherwise directed by your organization's logging policy.

ddl logs all data definition statements:

CREATE

ALTER

DROP

mod logs all ddl statements, plus data-modifying statements:

INSERT

UPDATE

DELETE

TRUNCATE

COPY FROM

(PREPARE, EXECUTE, and EXPLAIN ANALYZE statements are also logged if their contained command is of an appropriate type.)

For clients using extended query protocol, logging occurs when an Execute message is received, and values of the Bind parameters are included (with any embedded single-quote marks doubled).

Rationale:

Setting log_statement to align with your organization's security and logging policies facilitates later auditing and review of database activities.

Solution:
Execute the following SQL statement(s) as superuser to remediate this setting:

postgres=# alter system set log_statement='ddl';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

none

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_statement
sql_expect: STRING - ddl

Actual Value:
5432/template1:
* [""ddl""]","Execute the following SQL statement(s) as superuser to remediate this setting:

postgres=# alter system set log_statement='ddl';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

none","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.1.26 Ensure 'log_timezone' is set correctly - log_timezone is set correctly"" : [PASSED]

The log_timezone setting specifies the time zone to use in timestamps within log messages. This value is cluster-wide, so that all sessions will report timestamps consistently. Unless directed otherwise by your organization's logging policy, set this to either GMT or UTC.

Rationale:

Log entry timestamps should be configured for an appropriate time zone as defined by your organization's logging policy to ensure a lack of confusion around when a logged event occurred.

Note that this setting affects only the timestamps present in the logs. It does not affect the time zone in use by the database itself (for example, select now()), nor does it affect the host's time zone.

Solution:
Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_timezone = 'GMT';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

By default, the PGDG packages will set this to match the server's timezone in the Operating System.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show log_timezone
sql_expect: STRING - UTC

Actual Value:
5432/template1:
* [""UTC""]","Execute the following SQL statement(s) to remediate this setting:

postgres=# alter system set log_timezone = 'GMT';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

Default Value:

By default, the PGDG packages will set this to match the server's timezone in the Operating System.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.2 Ensure the PostgreSQL Audit Extension (pgAudit) is enabled - show pgaudit.log"" : [WARNING]

The PostgreSQL Audit Extension (pgAudit) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The goal of pgAudit is to provide PostgreSQL users with the capability to produce audit logs often required to comply with government, financial, or ISO certifications.

Rationale:

Basic statement logging can be provided by the standard logging facility with log_statement = all. This is acceptable for monitoring and other uses but does not provide the level of detail generally required for an audit. It is not enough to have a list of all the operations performed against the database, it must also be possible to find particular statements that are of interest to an auditor. The standard logging facility shows what the user requested, while pgAudit focuses on the details of what happened while the database was satisfying the request.

When logging SELECT and DML statements, pgAudit can be configured to log a separate entry for each relation referenced in a statement. No parsing is required to find all statements that touch a particular table. In fact, the goal is that the statement text is provided primarily for deep forensics and should not be required for an audit.

Impact:

Depending on settings, it is possible for pgAudit to generate an enormous volume of logging. Be careful to determine exactly what needs to be audit logged in your environment to avoid logging too much.

Solution:
To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:

# whoami
root
# dnf -y install pgaudit15_13
[snip]
Installed:
  pgaudit15_13-1.5.2-1.rhel9.x86_64

Complete!

pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:

enable pgAudit as an extension in the shared_preload_libraries parameter

indicate which classes of statements we want to log via the pgaudit.log parameter

and, finally, restart the PostgreSQL service:

$ vi ${PGDATA}/postgresql.conf

Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):

shared_preload_libraries = 'pgaudit'

OR

shared_preload_libraries = 'pgaudit,somethingelse'

Now, add a new pgaudit-specific entry:

# for this example we are logging the ddl and write operations
pgaudit.log='ddl,write'

Restart the PostgreSQL server for changes to take affect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [date] 10s ago

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show pgaudit.log
sql_expect: REGEX - (read|write|function|role|ddl|misc)

Error:
5432/template1:
  ERROR: error retrieving data: [M: unrecognized configuration parameter ""pgaudit.log""]","To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:

# whoami
root
# dnf -y install pgaudit15_13
[snip]
Installed:
  pgaudit15_13-1.5.2-1.rhel9.x86_64

Complete!

pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:

enable pgAudit as an extension in the shared_preload_libraries parameter

indicate which classes of statements we want to log via the pgaudit.log parameter

and, finally, restart the PostgreSQL service:

$ vi ${PGDATA}/postgresql.conf

Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):

shared_preload_libraries = 'pgaudit'

OR

shared_preload_libraries = 'pgaudit,somethingelse'

Now, add a new pgaudit-specific entry:

# for this example we are logging the ddl and write operations
pgaudit.log='ddl,write'

Restart the PostgreSQL server for changes to take affect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [date] 10s ago","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""3.2 Ensure the PostgreSQL Audit Extension (pgAudit) is enabled - pgaudit installed"" : [FAILED]

The PostgreSQL Audit Extension (pgAudit) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The goal of pgAudit is to provide PostgreSQL users with the capability to produce audit logs often required to comply with government, financial, or ISO certifications.

Rationale:

Basic statement logging can be provided by the standard logging facility with log_statement = all. This is acceptable for monitoring and other uses but does not provide the level of detail generally required for an audit. It is not enough to have a list of all the operations performed against the database, it must also be possible to find particular statements that are of interest to an auditor. The standard logging facility shows what the user requested, while pgAudit focuses on the details of what happened while the database was satisfying the request.

When logging SELECT and DML statements, pgAudit can be configured to log a separate entry for each relation referenced in a statement. No parsing is required to find all statements that touch a particular table. In fact, the goal is that the statement text is provided primarily for deep forensics and should not be required for an audit.

Impact:

Depending on settings, it is possible for pgAudit to generate an enormous volume of logging. Be careful to determine exactly what needs to be audit logged in your environment to avoid logging too much.

Solution:
To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:

# whoami
root
# dnf -y install pgaudit15_13
[snip]
Installed:
  pgaudit15_13-1.5.2-1.rhel9.x86_64

Complete!

pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:

enable pgAudit as an extension in the shared_preload_libraries parameter

indicate which classes of statements we want to log via the pgaudit.log parameter

and, finally, restart the PostgreSQL service:

$ vi ${PGDATA}/postgresql.conf

Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):

shared_preload_libraries = 'pgaudit'

OR

shared_preload_libraries = 'pgaudit,somethingelse'

Now, add a new pgaudit-specific entry:

# for this example we are logging the ddl and write operations
pgaudit.log='ddl,write'

Restart the PostgreSQL server for changes to take affect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [date] 10s ago

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4

Policy Value:
SQL_POLICY
sql_request: show shared_preload_libraries
sql_expect: REGEX - pgaudit

Actual Value:
5432/template1:
  [""rdsutils,pg_stat_statements""]","To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:

# whoami
root
# dnf -y install pgaudit15_13
[snip]
Installed:
  pgaudit15_13-1.5.2-1.rhel9.x86_64

Complete!

pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:

enable pgAudit as an extension in the shared_preload_libraries parameter

indicate which classes of statements we want to log via the pgaudit.log parameter

and, finally, restart the PostgreSQL service:

$ vi ${PGDATA}/postgresql.conf

Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):

shared_preload_libraries = 'pgaudit'

OR

shared_preload_libraries = 'pgaudit,somethingelse'

Now, add a new pgaudit-specific entry:

# for this example we are logging the ddl and write operations
pgaudit.log='ddl,write'

Restart the PostgreSQL server for changes to take affect:

# whoami
root
# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [date] 10s ago","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.2 Ensure excessive administrative privileges are revoked"" : [WARNING]

With respect to PostgreSQL administrative SQL commands, only superusers should have elevated privileges. PostgreSQL regular, or application, users should not possess the ability to create roles, create new databases, manage replication, or perform any other action deemed privileged. Typically, regular users should only be granted the minimal set of privileges commensurate with managing the application:

DDL (create table, create view, create index, etc.)

DML (select, insert, update, delete)

Further, it has become best practice to create separate roles for DDL and DML. Given an application called 'payroll', one would create the following users:

payroll_owner

payroll_user

Any DDL privileges would be granted to the payroll_owner account only, while DML privileges would be given to the payroll_user account only. This prevents accidental creation/altering/dropping of database objects by application code that runs as the payroll_user account.

Rationale:

By not restricting global administrative commands to superusers only, regular users granted excessive privileges may execute administrative commands with unintended and undesirable results.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
If any regular or application users have been granted excessive administrative rights, those privileges should be removed immediately via the PostgreSQL ALTER ROLE SQL command. Using the same example above, the following SQL statements revoke all unnecessary elevated administrative privileges from the regular user appuser:

# whoami
postgres
# psql -c 'ALTER ROLE appuser NOSUPERUSER;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOCREATEROLE;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOCREATEDB;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOREPLICATION;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOBYPASSRLS;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOINHERIT;'
ALTER ROLE

Verify the appuser now passes your check by having no defined Attributes:

# whoami
postgres
# psql -c '\du appuser'
          List of roles
Role name | Attributes | Member of
----------+------------+-----------
appuser   |            | {}

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select * from pg_user order by usename;
sql_expect: STRING - NULL

Actual Value:
5432/template1:
  [""inventory"",""17043"",""f"",""f"",""f"",""f"",""********"",null,null]
  [""luigi-luigi-096189eb8b9c48ba-ro-user"",""17049"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-096189eb8b9c48ba-rw-user"",""17048"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-17fbed605c0f4b6d-ro-user"",""17070"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-17fbed605c0f4b6d-rw-user"",""17069"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-2a0afced6d6e435f-ro-user"",""17075"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-2a0afced6d6e435f-rw-user"",""17074"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-2d2276b2f44e4558-ro-user"",""17034"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-2d2276b2f44e4558-rw-user"",""17033"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-2f239faccfe44979-ro-user"",""16960"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-2f239faccfe44979-rw-user"",""16959"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-4082c3cd42e9458b-ro-user"",""17072"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-4082c3cd42e9458b-rw-user"",""17071"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-441fcdd2c7f14c34-ro-user"",""17055"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-441fcdd2c7f14c34-rw-user"",""17054"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-47babf7c334a4d98-ro-user"",""17032"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-47babf7c334a4d98-rw-user"",""17031"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-48b8ff4dc20542f1-ro-user"",""17052"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-48b8ff4dc20542f1-rw-user"",""17051"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-5c6da32f34c9434e-ro-user"",""17036"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-5c6da32f34c9434e-rw-user"",""17035"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-5e2dd402dc584911-ro-user"",""17060"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-5e2dd402dc584911-rw-user"",""17059"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-86dc3654c44942e1-ro-user"",""17046"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-86dc3654c44942e1-rw-user"",""17045"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-9136eb1bd18e493a-ro-user"",""17057"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-9136eb1bd18e493a-rw-user"",""17056"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-9aa8bc3e65ab4d02-ro-user"",""16996"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-9aa8bc3e65ab4d02-rw-user"",""16995"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-b963a9f11a0944dd-ro-user"",""17083"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-b963a9f11a0944dd-rw-user"",""17082"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""luigi-luigi-f7526b229ed54823-ro-user"",""17064"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-ro-role}""]
  [""luigi-luigi-f7526b229ed54823-rw-user"",""17063"",""f"",""f"",""f"",""f"",""********"",null,""{role=luigi-luigi-rw-role}""]
  [""rdsadmin"",""10"",""t"",""t"",""t"",""t"",""********"",""infinity"",""{TimeZone=utc,log_statement=all,log_min_error_statement=debug5,log_min_messages=panic,exit_on_error=0,statement_timeout=0,role=rdsadmin,auto_explain.log_min_duration=-1,temp_file_limit=-1,search_path=pg_catalog,synchronous_commit=local,default_tablespace=,pg_hint_plan.enable_hint=off,default_transaction_read_only=off}""]
  [""security_scanner"",""17047"",""f"",""f"",""f"",""f"",""********"",null,null]
  [""superuser"",""16401"",""t"",""f"",""f"",""f"",""********"",""infinity"",null]","If any regular or application users have been granted excessive administrative rights, those privileges should be removed immediately via the PostgreSQL ALTER ROLE SQL command. Using the same example above, the following SQL statements revoke all unnecessary elevated administrative privileges from the regular user appuser:

# whoami
postgres
# psql -c 'ALTER ROLE appuser NOSUPERUSER;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOCREATEROLE;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOCREATEDB;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOREPLICATION;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOBYPASSRLS;'
ALTER ROLE
# psql -c 'ALTER ROLE appuser NOINHERIT;'
ALTER ROLE

Verify the appuser now passes your check by having no defined Attributes:

# whoami
postgres
# psql -c '\du appuser'
          List of roles
Role name | Attributes | Member of
----------+------------+-----------
appuser   |            | {}","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.3 Ensure excessive function privileges are revoked"" : [WARNING]

In certain situations, to provide the required functionality, PostgreSQL needs to execute internal logic (stored procedures, functions, triggers, etc.) and/or external code modules with elevated privileges. However, if the privileges required for execution are at a higher level than the privileges assigned to organizational users invoking the functionality applications/programs, those users are indirectly provided with greater privileges than assigned by their organization. This is known as privilege elevation. Privilege elevation must be utilized only where necessary. Execute privileges for application functions should be restricted to authorized users only.

Rationale:

Ideally, all application source code should be vetted to validate interactions between the application and the logic in the database, but this is usually not possible or feasible with available resources even if the source code is available. The DBA should attempt to obtain assurances from the development organization that this issue has been addressed and should document what has been discovered. The DBA should also inspect all application logic stored in the database (in the form of functions, rules, and triggers) for excessive privileges.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Where possible, revoke SECURITY DEFINER on PostgreSQL functions. To change a SECURITY DEFINER function to SECURITY INVOKER, run the following SQL:

# whoami
root
# sudo -iu postgres
# psql -c 'ALTER FUNCTION [functionname] SECURITY INVOKER;'

If it is not possible to revoke SECURITY DEFINER, ensure the function can be executed by only the accounts that absolutely need such functionality:

postgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres,appreader=X/postgres}
(1 row)
postgres=# REVOKE EXECUTE ON FUNCTION delete_customer(integer,boolean) FROM appreader;
REVOKE
postgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres}
(1 row)

Based on the output above, appreader=X/postgres no longer exists in the proacl column results returned from the query and confirms appreader is no longer granted execute privilege on the function.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: SELECT nspname, proname, proargtypes, prosecdef, rolname, proconfig FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid JOIN pg_authid a ON a.oid = p.proowner WHERE prosecdef OR NOT proconfig IS NULL;
sql_expect: STRING - MANUAL_REVIEW

Error:
5432/template1:
  ERROR: error retrieving data: [M: permission denied for table pg_authid]","Where possible, revoke SECURITY DEFINER on PostgreSQL functions. To change a SECURITY DEFINER function to SECURITY INVOKER, run the following SQL:

# whoami
root
# sudo -iu postgres
# psql -c 'ALTER FUNCTION [functionname] SECURITY INVOKER;'

If it is not possible to revoke SECURITY DEFINER, ensure the function can be executed by only the accounts that absolutely need such functionality:

postgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres,appreader=X/postgres}
(1 row)
postgres=# REVOKE EXECUTE ON FUNCTION delete_customer(integer,boolean) FROM appreader;
REVOKE
postgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres}
(1 row)

Based on the output above, appreader=X/postgres no longer exists in the proacl column results returned from the query and confirms appreader is no longer granted execute privilege on the function.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.4 Ensure excessive DML privileges are revoked"" : [WARNING]

DML (insert, update, delete) operations at the table level should be restricted to only authorized users. PostgreSQL manages table-level DML permissions via the GRANT statement.

Rationale:

Excessive DML grants can lead to unprivileged users changing or deleting information without proper authorization.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
If a given database user has been granted excessive DML privileges for a given database table, those privileges should be revoked immediately using the REVOKE SQL command.

Continuing with the example above, remove unauthorized grants for appreader user using the REVOKE statement and verify the Boolean values are now false.

postgres=# REVOKE INSERT, UPDATE, DELETE ON TABLE customer FROM appreader;
REVOKE

postgres=# select t.tablename, u.usename,
       has_table_privilege(u.usename, t.tablename, 'select') as select,
       has_table_privilege(u.usename, t.tablename, 'insert') as insert,
       has_table_privilege(u.usename, t.tablename, 'update') as update,
       has_table_privilege(u.usename, t.tablename, 'delete') as delete
from   pg_tables t, pg_user u
where  t.tablename = 'customer'
and    u.usename in ('appwriter','appreader');

tablename |  usename  | select | insert | update | delete
----------+-----------+--------+--------+--------+--------
customer  | appwriter | t      | t      | t      | t
customer  | appreader | t      | f      | f      | f
(2 rows)

Note: For versions of PostgreSQL prior to version 15, CVE-2018-1058 is applicable and it is recommended that all privileges be revoked from the public schema for all users on all databases. If you have upgraded from one of these earlier releases, this CVE is not fixed for you during an upgrade. You can correct this CVE by issuing:

postgres=# REVOKE CREATE ON SCHEMA public FROM PUBLIC;
REVOKE

Default Value:

The table owner/creator has full privileges; all other users must be explicitly granted access.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
WARNING

Actual Value:
5432/template1:
WARNING","If a given database user has been granted excessive DML privileges for a given database table, those privileges should be revoked immediately using the REVOKE SQL command.

Continuing with the example above, remove unauthorized grants for appreader user using the REVOKE statement and verify the Boolean values are now false.

postgres=# REVOKE INSERT, UPDATE, DELETE ON TABLE customer FROM appreader;
REVOKE

postgres=# select t.tablename, u.usename,
       has_table_privilege(u.usename, t.tablename, 'select') as select,
       has_table_privilege(u.usename, t.tablename, 'insert') as insert,
       has_table_privilege(u.usename, t.tablename, 'update') as update,
       has_table_privilege(u.usename, t.tablename, 'delete') as delete
from   pg_tables t, pg_user u
where  t.tablename = 'customer'
and    u.usename in ('appwriter','appreader');

tablename |  usename  | select | insert | update | delete
----------+-----------+--------+--------+--------+--------
customer  | appwriter | t      | t      | t      | t
customer  | appreader | t      | f      | f      | f
(2 rows)

Note: For versions of PostgreSQL prior to version 15, CVE-2018-1058 is applicable and it is recommended that all privileges be revoked from the public schema for all users on all databases. If you have upgraded from one of these earlier releases, this CVE is not fixed for you during an upgrade. You can correct this CVE by issuing:

postgres=# REVOKE CREATE ON SCHEMA public FROM PUBLIC;
REVOKE

Default Value:

The table owner/creator has full privileges; all other users must be explicitly granted access.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.5 Ensure Row Level Security (RLS) is configured correctly - RLS is configured correctly"" : [WARNING]

In addition to the SQL-standard privilege system available through GRANT, tables can have row security policies that restrict, on a per-user basis, which individual rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as Row Level Security (RLS).

By default, tables do not have any policies, so if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating. Row security policies can be specific to commands, to roles, or to both. A policy can be specified to apply to ALL commands, or to any combination of SELECT, INSERT, UPDATE, or DELETE. Multiple roles can be assigned to a given policy, and normal role membership and inheritance rules apply.

If you use RLS and apply restrictive policies to certain users, it is important that the Bypass RLS privilege not be granted to any unauthorized users. This privilege overrides RLS-enabled tables and associated policies. Generally, only superusers and elevated users should possess this privilege.

Rationale:

If RLS policies and privileges are not configured correctly, users could perform actions on tables that they are not authorized to perform, such as inserting, updating, or deleting rows.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
Again, we are using the example from the PostgreSQL documentation using the example passwd table. We will create three database roles to illustrate the workings of RLS:

postgres=# CREATE ROLE admin;
CREATE ROLE
postgres=# CREATE ROLE bob;
CREATE ROLE
postgres=# CREATE ROLE alice;
CREATE ROLE

Now, we will insert known data into the passwd table:

postgres=# INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');
INSERT 0 1

And we will enable RLS on the table:

postgres=# ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;
ALTER TABLE

Now that RLS is enabled, we need to define one or more policies. Create the administrator policy and allow it access to all rows:

postgres=# CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
CREATE POLICY

Create a policy for normal users to view all rows:

postgres=# CREATE POLICY all_view ON passwd FOR SELECT USING (true);
CREATE POLICY

Create a policy for normal users that allows them to update only their own rows and to limit what values can be set for their login shell:

postgres=# CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );
CREATE POLICY

Grant all the normal rights on the table to the admin user:

postgres=# GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
GRANT

Grant only select access on non-sensitive columns to everyone:

postgres=# GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
GRANT

Grant update to only the sensitive columns:

postgres=# GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
GRANT

Ensure that no one has been granted Bypass RLS inadvertently, by running the psql display command \du+. If unauthorized users do have Bypass RLS granted then resolve this using the ALTER ROLE <user> NOBYPASSRLS; command.

You can now verify that 'admin', 'bob', and 'alice' are properly restricted by querying the passwd table as each of these roles.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
WARNING

Actual Value:
5432/template1:
WARNING","Again, we are using the example from the PostgreSQL documentation using the example passwd table. We will create three database roles to illustrate the workings of RLS:

postgres=# CREATE ROLE admin;
CREATE ROLE
postgres=# CREATE ROLE bob;
CREATE ROLE
postgres=# CREATE ROLE alice;
CREATE ROLE

Now, we will insert known data into the passwd table:

postgres=# INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');
INSERT 0 1

And we will enable RLS on the table:

postgres=# ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;
ALTER TABLE

Now that RLS is enabled, we need to define one or more policies. Create the administrator policy and allow it access to all rows:

postgres=# CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
CREATE POLICY

Create a policy for normal users to view all rows:

postgres=# CREATE POLICY all_view ON passwd FOR SELECT USING (true);
CREATE POLICY

Create a policy for normal users that allows them to update only their own rows and to limit what values can be set for their login shell:

postgres=# CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );
CREATE POLICY

Grant all the normal rights on the table to the admin user:

postgres=# GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
GRANT

Grant only select access on non-sensitive columns to everyone:

postgres=# GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
GRANT

Grant update to only the sensitive columns:

postgres=# GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
GRANT

Ensure that no one has been granted Bypass RLS inadvertently, by running the psql display command \du+. If unauthorized users do have Bypass RLS granted then resolve this using the ALTER ROLE <user> NOBYPASSRLS; command.

You can now verify that 'admin', 'bob', and 'alice' are properly restricted by querying the passwd table as each of these roles.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.6 Ensure the set_user extension is installed"" : [FAILED]

PostgreSQL access to the superuser database role must be controlled and audited to prevent unauthorized access.

Note: Prior to performing this audit you must create a roletree view. Here are the procedures to create this view:

postgres=#

CREATE OR REPLACE VIEW roletree AS

WITH RECURSIVE

roltree AS (

  SELECT u.rolname AS rolname,

         u.oid AS roloid,

         u.rolcanlogin,

         u.rolsuper,

         '{}'::name[] AS rolparents,

         NULL::oid AS parent_roloid,

         NULL::name AS parent_rolname

  FROM pg_catalog.pg_authid u

  LEFT JOIN pg_catalog.pg_auth_members m on u.oid = m.member

  LEFT JOIN pg_catalog.pg_authid g on m.roleid = g.oid

  WHERE g.oid IS NULL

  UNION ALL

  SELECT u.rolname AS rolname,

         u.oid AS roloid,

         u.rolcanlogin,

         u.rolsuper,

         t.rolparents || g.rolname AS rolparents,

         g.oid AS parent_roloid,

         g.rolname AS parent_rolname

  FROM pg_catalog.pg_authid u

  JOIN pg_catalog.pg_auth_members m on u.oid = m.member

  JOIN pg_catalog.pg_authid g on m.roleid = g.oid

  JOIN roltree t on t.roloid = g.oid

)

SELECT

  r.rolname,

  r.roloid,

  r.rolcanlogin,

  r.rolsuper,

  r.rolparents

FROM roltree r

ORDER BY 1;

Rationale:

Even when reducing and limiting the access to the superuser role as described earlier in this benchmark, it is still difficult to determine who accessed the superuser role and what actions were taken using that role. As such, it is ideal to prevent anyone from logging in as the superuser and forcing them to escalate their role. This model is used at the OS level by the use of sudo and should be emulated in the database. The set_user extension allows for this setup.

Impact:

Much like the venerable sudo does for the OS, set_user manages superuser access for PostgreSQL. Complete configuration of set_user is documented at the extension's website and should be reviewed to ensure the logging entries that your organization cares about are properly configured.

Note that some external tools assume they can connect as the postgres user by default and this is no longer true when set_user is deployed. You may find some tools need different options, reconfigured, or even abandoned to compensate for this.

Solution:
We will install the set_user extension:

# whoami
root
# dnf -y install set_user_13
[snip]
Installed:
  set_user_13-4.0.1-2.rhel9.x86_64

Complete!

Now that set_user is installed, we need to tell PostgreSQL to load its library:

# whoami
root
# vi ~postgres/13/data/postgresql.conf

Find the shared_preload_libraries entry, and add 'set_user' to it (preserving any existing entries):

shared_preload_libraries = 'set_user'

OR

shared_preload_libraries = 'set_user,pgaudit,somethingelse'

Restart the PostgreSQL server for changes to take effect:

# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [timestamp]; 1s ago

And now, we can install the extension with SQL:

# su - postgres
# psql
postgres=# select * from pg_available_extensions where name = 'set_user';
  name   | default_version | installed_version |                  comment
---------+-----------------+-------------------+-----------------------------
set_user | 4.0.1           |                   | similar to SET ROLE but with
         |                 |                   | added logging
(1 row)

postgres=# create extension set_user;
CREATE EXTENSION
postgres=# select * from pg_available_extensions where name = 'set_user';
  name   | default_version | installed_version |                  comment
---------+-----------------+-------------------+-----------------------------
set_user | 4.0.1           | 4.0.1             | similar to SET ROLE but with
         |                 |                   | added logging
(1 row)

Now, we use GRANT to configure each DBA role to allow it to use the set_user functions. In the example below, we will configure my db user doug. (You would do this for each DBA's normal user role.)

postgres=# grant execute on function set_user(text) to doug;
GRANT
postgres=# grant execute on function set_user_u(text) to doug;
GRANT

Connect to PostgreSQL as yourself and verify it works as expected:

# whoami
psql
# psql -U doug -d postgres -h 127.0.0.1
postgres=> select set_user('postgres');
ERROR:  switching to superuser not allowed
HINT:  Use 'set_user_u' to escalate.
postgres=> select set_user_u('postgres');
 set_user_u
------------
 OK
(1 row)
postgres=# select current_user, session_user;
 current_user | session_user
--------------+--------------
 postgres     | doug
(1 row)
postgres=# select reset_user();
 reset_user
------------
 OK
(1 row)
postgres=> select current_user, session_user;
 current_user | session_user
--------------+--------------
 doug         | doug
(1 row)

Once all DBA's normal user accounts have been GRANTed permission, revoke the ability to login as the postgres (superuser) user:

postgres=# ALTER USER postgres NOLOGIN;
ALTER ROLE

Which results in:

$ psql
psql: FATAL:  role 'postgres' is not permitted to log in
$ psql -U doug -d postgres -h 127.0.0.1
psql (13.10)

Revoke SUPERUSER and/or LOGIN from any other roles that were previously identified:

postgres=# ALTER USER usera NOSUPERUSER; -- revoke superuser
ALTER ROLE
postgres=# ALTER USER usera NOLOGIN; -- revoke login
ALTER ROLE
postgres=# ALTER USER usera NOSUPERUSER NOLOGIN; -- revoke both at once
ALTER ROLE

Note that we show dropping the privileges both individually and as one. Pick an appropriate version based on your application/business needs.

Remove any escalated privileges on users granted indirectly that were previously identified using the roletree view:

postgres=# REVOKE name_of_granting_role FROM bob; -- an example only
REVOKE ROLE

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1A,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
SQL_POLICY
sql_request: select name from pg_available_extensions where name = 'set_user';
sql_expect: STRING - set_user

Actual Value:
5432/template1:
  No data returned.","We will install the set_user extension:

# whoami
root
# dnf -y install set_user_13
[snip]
Installed:
  set_user_13-4.0.1-2.rhel9.x86_64

Complete!

Now that set_user is installed, we need to tell PostgreSQL to load its library:

# whoami
root
# vi ~postgres/13/data/postgresql.conf

Find the shared_preload_libraries entry, and add 'set_user' to it (preserving any existing entries):

shared_preload_libraries = 'set_user'

OR

shared_preload_libraries = 'set_user,pgaudit,somethingelse'

Restart the PostgreSQL server for changes to take effect:

# systemctl restart postgresql-13
# systemctl status postgresql-13|grep 'ago$'
   Active: active (running) since [timestamp]; 1s ago

And now, we can install the extension with SQL:

# su - postgres
# psql
postgres=# select * from pg_available_extensions where name = 'set_user';
  name   | default_version | installed_version |                  comment
---------+-----------------+-------------------+-----------------------------
set_user | 4.0.1           |                   | similar to SET ROLE but with
         |                 |                   | added logging
(1 row)

postgres=# create extension set_user;
CREATE EXTENSION
postgres=# select * from pg_available_extensions where name = 'set_user';
  name   | default_version | installed_version |                  comment
---------+-----------------+-------------------+-----------------------------
set_user | 4.0.1           | 4.0.1             | similar to SET ROLE but with
         |                 |                   | added logging
(1 row)

Now, we use GRANT to configure each DBA role to allow it to use the set_user functions. In the example below, we will configure my db user doug. (You would do this for each DBA's normal user role.)

postgres=# grant execute on function set_user(text) to doug;
GRANT
postgres=# grant execute on function set_user_u(text) to doug;
GRANT

Connect to PostgreSQL as yourself and verify it works as expected:

# whoami
psql
# psql -U doug -d postgres -h 127.0.0.1
postgres=> select set_user('postgres');
ERROR:  switching to superuser not allowed
HINT:  Use 'set_user_u' to escalate.
postgres=> select set_user_u('postgres');
 set_user_u
------------
 OK
(1 row)
postgres=# select current_user, session_user;
 current_user | session_user
--------------+--------------
 postgres     | doug
(1 row)
postgres=# select reset_user();
 reset_user
------------
 OK
(1 row)
postgres=> select current_user, session_user;
 current_user | session_user
--------------+--------------
 doug         | doug
(1 row)

Once all DBA's normal user accounts have been GRANTed permission, revoke the ability to login as the postgres (superuser) user:

postgres=# ALTER USER postgres NOLOGIN;
ALTER ROLE

Which results in:

$ psql
psql: FATAL:  role 'postgres' is not permitted to log in
$ psql -U doug -d postgres -h 127.0.0.1
psql (13.10)

Revoke SUPERUSER and/or LOGIN from any other roles that were previously identified:

postgres=# ALTER USER usera NOSUPERUSER; -- revoke superuser
ALTER ROLE
postgres=# ALTER USER usera NOLOGIN; -- revoke login
ALTER ROLE
postgres=# ALTER USER usera NOSUPERUSER NOLOGIN; -- revoke both at once
ALTER ROLE

Note that we show dropping the privileges both individually and as one. Pick an appropriate version based on your application/business needs.

Remove any escalated privileges on users granted indirectly that were previously identified using the roletree view:

postgres=# REVOKE name_of_granting_role FROM bob; -- an example only
REVOKE ROLE","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""4.7 Make use of predefined roles"" : [WARNING]

PostgreSQL provides a set of predefined roles that provide access to certain commonly needed privileged capabilities and information. Administrators can GRANT these roles to users and/or other roles in their environment, providing those users with access to the specified capabilities and information.

Rationale:

In keeping with the principle of least privilege, judicious use of the PostgreSQL predefined roles can greatly limit the access to privileged, or superuser, access.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
If you've determined that one or more of the predefined roles can be used, simply GRANT it:

postgres=# GRANT pg_monitor TO doug;
GRANT ROLE

And then remove superuser from the account:

postgres=# ALTER ROLE doug NOSUPERUSER;
ALTER ROLE
postgres=# select rolname from pg_roles where rolsuper is true;
 rolname
----------
 postgres
(1 row)

Default Value:

The following predefined roles exist in PostgreSQL 13.x:

pg_read_all_settings

Read all configuration variables, even those normally visible only to superuser.

pg_read_all_stats

Read all pg_stat_* views and use various statistics related extensions, even those normally visible only to superuser.

pg_stat_scan_tables

Execute monitoring functions that may take ACCESS SHARE locks on tables, potentially for a long time.

pg_monitor

Read/execute various monitoring views and functions. This role is a member of pg_read_all_settings, pg_read_all_stats and pg_stat_scan_tables.

pg_signal_backend

Signal another backend to cancel a query or terminate its session.

pg_read_server_files

Allow reading files from any location the database can access on the server with COPY and other file-access functions.

pg_write_server_files

Allow writing to files in any location the database can access on the server with COPY and other file-access functions.

pg_execute_server_program

Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.

Administrators can grant access to these roles to users using the GRANT command.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select rolname from pg_roles where rolsuper is true;
sql_expect: STRING - rolname

Actual Value:
5432/template1:
  [""rdsadmin""]","If you've determined that one or more of the predefined roles can be used, simply GRANT it:

postgres=# GRANT pg_monitor TO doug;
GRANT ROLE

And then remove superuser from the account:

postgres=# ALTER ROLE doug NOSUPERUSER;
ALTER ROLE
postgres=# select rolname from pg_roles where rolsuper is true;
 rolname
----------
 postgres
(1 row)

Default Value:

The following predefined roles exist in PostgreSQL 13.x:

pg_read_all_settings

Read all configuration variables, even those normally visible only to superuser.

pg_read_all_stats

Read all pg_stat_* views and use various statistics related extensions, even those normally visible only to superuser.

pg_stat_scan_tables

Execute monitoring functions that may take ACCESS SHARE locks on tables, potentially for a long time.

pg_monitor

Read/execute various monitoring views and functions. This role is a member of pg_read_all_settings, pg_read_all_stats and pg_stat_scan_tables.

pg_signal_backend

Signal another backend to cancel a query or terminate its session.

pg_read_server_files

Allow reading files from any location the database can access on the server with COPY and other file-access functions.

pg_write_server_files

Allow writing to files in any location the database can access on the server with COPY and other file-access functions.

pg_execute_server_program

Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.

Administrators can grant access to these roles to users using the GRANT command.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.1 Understanding attack vectors and runtime parameters"" : [WARNING]

Understanding the vulnerability of PostgreSQL runtime parameters by the particular delivery method, or attack vector.

Rationale:

There are as many ways of compromising a server as there are runtime parameters. A combination of any one or more of them executed at the right time under the right conditions has the potential to compromise the RDBMS. Mitigating risk is dependent upon one's understanding of the attack vectors and includes:

Via user session: includes those runtime parameters that can be set by a ROLE that persists for the life of a server-client session.

Via attribute: includes those runtime parameters that can be set by a ROLE during a server-client session that can be assigned as an attribute for an entity such as a table, index, database, or role.

Via server reload: includes those runtime parameters that can be set by the superuser using a SIGHUP or configuration file reload command and affects the entire cluster.

Via server restart: includes those runtime parameters that can be set and effected by restarting the server process and affects the entire cluster.

Impact:

It can be difficult to totally eliminate risk. Once changed, detecting a miscreant parameter can become problematic.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
In the case of a changed parameter, the value is returned back to its default value. In the case of a successful exploit of an already set runtime parameter then an analysis must be carried out to determine the best approach in mitigating the risk to prevent future exploitation.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
WARNING

Actual Value:
5432/template1:
WARNING","In the case of a changed parameter, the value is returned back to its default value. In the case of a successful exploit of an already set runtime parameter then an analysis must be carried out to determine the best approach in mitigating the risk to prevent future exploitation.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - ignore_system_indexes"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'ignore_system_indexes';
sql_expect: STRING - ignore_system_indexes
sql_expect: STRING - off

Actual Value:
5432/template1:
* [""ignore_system_indexes"",""off""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - jit_debugging_support"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'jit_debugging_support';
sql_expect: STRING - jit_debugging_support
sql_expect: STRING - off

Actual Value:
5432/template1:
* [""jit_debugging_support"",""off""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - jit_profiling_support"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'jit_profiling_support';
sql_expect: STRING - jit_profiling_support
sql_expect: STRING - off

Actual Value:
5432/template1:
* [""jit_profiling_support"",""off""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - log_connections"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'log_connections';
sql_expect: STRING - log_connections
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""log_connections"",""on""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - log_disconnections"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'log_disconnections';
sql_expect: STRING - log_disconnections
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""log_disconnections"",""on""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.2 Ensure 'backend' runtime parameters are configured correctly - post_auth_delay"" : [PASSED]

In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be potentially compromised via these parameters.

Rationale:

A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files.

Solution:
Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'post_auth_delay';
sql_expect: STRING - post_auth_delay
sql_expect: INTEGER - 0

Actual Value:
5432/template1:
* [""post_auth_delay"",""0""]","Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.

Query the view pg_settings and compare with previous query outputs for any changes.

Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.3 Ensure 'Postmaster' Runtime Parameters are Configured"" : [WARNING]

PostgreSQL runtime parameters that are executed by the postmaster process.

Rationale:

The postmaster process is the supervisory process that assigns a backend process to an incoming client connection. The postmaster manages key runtime parameters that are either shared by all backend connections or needed by the postmaster process itself to run.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Once detected, the unauthorized/undesired change can be corrected by editing the altered configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:

Query the view pg_settings and compare with previous query outputs for any changes

Review the configuration files postgresql.conf and postgresql.auto.conf and compare with previously archived file copies for any changes

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context = 'postmaster' order by 1
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/template1:
  [""archive_mode"",""on""]
  [""autovacuum_freeze_max_age"",""200000000""]
  [""autovacuum_max_workers"",""6""]
  [""autovacuum_multixact_freeze_max_age"",""400000000""]
  [""bonjour"",""off""]
  [""bonjour_name"",null]
  [""cluster_name"",null]
  [""config_file"",""/rdsdbdata/config/postgresql.conf""]
  [""data_directory"",""/rdsdbdata/db""]
  [""data_sync_retry"",""off""]
  [""dynamic_shared_memory_type"",""posix""]
  [""event_source"",""PostgreSQL""]
  [""external_pid_file"",null]
  [""hba_file"",""/rdsdbdata/config/pg_hba.conf""]
  [""hot_standby"",""off""]
  [""huge_pages"",""on""]
  [""ident_file"",""/rdsdbdata/config/pg_ident.conf""]
  [""ignore_invalid_pages"",""off""]
  [""jit_provider"",""llvmjit""]
  [""listen_addresses"",""*""]
  [""logging_collector"",""on""]
  [""max_connections"",""1708""]
  [""max_files_per_process"",""1000""]
  [""max_locks_per_transaction"",""64""]
  [""max_logical_replication_workers"",""10""]
  [""max_pred_locks_per_transaction"",""64""]
  [""max_prepared_transactions"",""0""]
  [""max_replication_slots"",""20""]
  [""max_wal_senders"",""35""]
  [""max_worker_processes"",""10""]
  [""old_snapshot_threshold"",""-1""]
  [""pg_stat_statements.max"",""5000""]
  [""port"",""5432""]
  [""rds.instance_store_replication_tooling"",""off""]
  [""rds.logical_replication"",""on""]
  [""rds.max_connections_counters_entries"",""5000""]
  [""rds.max_connections_counters_entries_sl"",""1000""]
  [""rds.max_rsdl_counters_entries"",""5000""]
  [""rds.max_stored_credentials"",""10""]
  [""rds.rds_superuser_reserved_connections"",""2""]
  [""rds.restrict_password_commands"",""off""]
  [""rds.tablespace_path_prefix"",""/rdsdbdata/db/base/tablespace""]
  [""rds.wal_allocator_dir"",""/rdslocalstorage/prealloc""]
  [""recovery_target"",null]
  [""recovery_target_action"",""pause""]
  [""recovery_target_inclusive"",""on""]
  [""recovery_target_lsn"",null]
  [""recovery_target_name"",null]
  [""recovery_target_time"",null]
  [""recovery_target_timeline"",""latest""]
  [""recovery_target_xid"",null]
  [""restore_command"",null]
  [""shared_buffers"",""497015""]
  [""shared_memory_type"",""mmap""]
  [""shared_preload_libraries"",""rdsutils,pg_stat_statements""]
  [""superuser_reserved_connections"",""3""]
  [""track_activity_query_size"",""4096""]
  [""track_commit_timestamp"",""off""]
  [""unix_socket_directories"",""/tmp""]
  [""unix_socket_group"",""rdsdb""]
  [""unix_socket_permissions"",""0666""]
  [""wal_buffers"",""8192""]
  [""wal_level"",""logical""]
  [""wal_log_hints"",""off""]","Once detected, the unauthorized/undesired change can be corrected by editing the altered configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:

Query the view pg_settings and compare with previous query outputs for any changes

Review the configuration files postgresql.conf and postgresql.auto.conf and compare with previously archived file copies for any changes

Examine the process output and look for parameters that were used at server startup:

ps -few | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.4 Ensure 'SIGHUP' Runtime Parameters are Configured"" : [WARNING]

PostgreSQL runtime parameters that are executed by the SIGHUP signal.

Rationale:

In order to define server behavior and optimize server performance, the server's superuser has the privilege of setting these parameters which are found in the configuration files postgresql.conf and pg_hba.conf. Alternatively, those parameters found in postgresql.conf can also be changed using a server login session and executing the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Restore all values in the PostgreSQL configuration files and invoke the server to reload the configuration files.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context = 'sighup' order by 1
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/template1:
  [""allow_system_table_mods"",""off""]
  [""archive_cleanup_command"",null]
  [""archive_command"",""/etc/rds/dbbin/pgscripts/rds_wal_archive %p skipTimeCheckForWalSegmentAndReadyFile""]
  [""archive_timeout"",""300""]
  [""authentication_timeout"",""60""]
  [""autovacuum"",""on""]
  [""autovacuum_analyze_scale_factor"",""0.05""]
  [""autovacuum_analyze_threshold"",""50""]
  [""autovacuum_naptime"",""15""]
  [""autovacuum_vacuum_cost_delay"",""2""]
  [""autovacuum_vacuum_cost_limit"",""200""]
  [""autovacuum_vacuum_insert_scale_factor"",""0.2""]
  [""autovacuum_vacuum_insert_threshold"",""1000""]
  [""autovacuum_vacuum_scale_factor"",""0.1""]
  [""autovacuum_vacuum_threshold"",""50""]
  [""autovacuum_work_mem"",""524288""]
  [""bgwriter_delay"",""200""]
  [""bgwriter_flush_after"",""64""]
  [""bgwriter_lru_maxpages"",""100""]
  [""bgwriter_lru_multiplier"",""2""]
  [""checkpoint_completion_target"",""0.9""]
  [""checkpoint_flush_after"",""32""]
  [""checkpoint_timeout"",""300""]
  [""checkpoint_warning"",""30""]
  [""db_user_namespace"",""off""]
  [""fsync"",""on""]
  [""full_page_writes"",""on""]
  [""hot_standby_feedback"",""off""]
  [""krb_caseins_users"",""off""]
  [""krb_server_keyfile"",""/rdsdbdata/config/keytab""]
  [""log_autovacuum_min_duration"",""10000""]
  [""log_checkpoints"",""on""]
  [""log_destination"",""stderr""]
  [""log_directory"",""/rdsdbdata/log/error""]
  [""log_file_mode"",""0644""]
  [""log_filename"",""postgresql.log.%Y-%m-%d-%H""]
  [""log_hostname"",""off""]
  [""log_line_prefix"",""%t:%r:%u@%d:[%p]:""]
  [""log_rotation_age"",""60""]
  [""log_rotation_size"",""10240""]
  [""log_timezone"",""UTC""]
  [""log_truncate_on_rotation"",""off""]
  [""max_pred_locks_per_page"",""2""]
  [""max_pred_locks_per_relation"",""-2""]
  [""max_slot_wal_keep_size"",""-1""]
  [""max_standby_archive_delay"",""30000""]
  [""max_standby_streaming_delay"",""30000""]
  [""max_sync_workers_per_subscription"",""2""]
  [""max_wal_size"",""25600""]
  [""min_wal_size"",""2048""]
  [""pg_stat_statements.save"",""on""]
  [""pre_auth_delay"",""0""]
  [""primary_slot_name"",null]
  [""promote_trigger_file"",null]
  [""rds.allowed_extensions"",""*""]
  [""rds.check_execution_context"",""on""]
  [""rds.check_extension_connections"",""on""]
  [""rds.connections_counters_dealloc_percent"",""5""]
  [""rds.enable_connections_counters"",""on""]
  [""rds.enable_logical_seed_lsn"",""on""]
  [""rds.enable_rsdl_counters"",""on""]
  [""rds.force_admin_logging_level"",""disabled""]
  [""rds.force_autovacuum_logging_level"",""warning""]
  [""rds.internal_databases"",""rdsadmin,template0""]
  [""rds.recovery_target_lsn"",null]
  [""rds.restrict_subconninfo"",""off""]
  [""rds.rsdl_counters_dealloc_percent"",""5""]
  [""rds.syncrep_query_cancels"",""off""]
  [""rds.temp_tablespaces"",""rds_temp_tablespace""]
  [""rds.wal_allocator_max_size"",""192""]
  [""rds.walreceiver_send_archived_lsn_interval"",""5""]
  [""recovery_end_command"",null]
  [""recovery_min_apply_delay"",""0""]
  [""restart_after_crash"",""on""]
  [""ssl"",""on""]
  [""ssl_ca_file"",""/rdsdbdata/rds-metadata/ca-cert.pem""]
  [""ssl_cert_file"",""/rdsdbdata/rds-metadata/server-cert.pem""]
  [""ssl_ciphers"",""HIGH:!aNULL:!3DES""]
  [""ssl_crl_file"",null]
  [""ssl_dh_params_file"",null]
  [""ssl_ecdh_curve"",""prime256v1""]
  [""ssl_key_file"",""/rdsdbdata/rds-metadata/server-key.pem""]
  [""ssl_max_protocol_version"",null]
  [""ssl_min_protocol_version"",""TLSv1.2""]
  [""ssl_passphrase_command"",null]
  [""ssl_passphrase_command_supports_reload"",""off""]
  [""ssl_prefer_server_ciphers"",""on""]
  [""stats_temp_directory"",""/rdsdbdata/db/pg_stat_tmp""]
  [""synchronous_standby_names"",null]
  [""syslog_facility"",""local0""]
  [""syslog_ident"",""postgres""]
  [""syslog_sequence_numbers"",""on""]
  [""syslog_split_messages"",""on""]
  [""trace_recovery_messages"",""log""]
  [""vacuum_defer_cleanup_age"",""0""]
  [""wal_keep_size"",""2048""]
  [""wal_receiver_create_temp_slot"",""off""]
  [""wal_receiver_status_interval"",""10""]
  [""wal_receiver_timeout"",""30000""]
  [""wal_retrieve_retry_interval"",""5000""]
  [""wal_sync_method"",""fdatasync""]
  [""wal_writer_delay"",""200""]
  [""wal_writer_flush_after"",""128""]","Restore all values in the PostgreSQL configuration files and invoke the server to reload the configuration files.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.5 Ensure 'Superuser' Runtime Parameters are Configured"" : [WARNING]

PostgreSQL runtime parameters that can only be executed by the server's superuser, postgres.

Rationale:

In order to improve and optimize server performance, the server's superuser has the privilege of setting these parameters which are found in the configuration file postgresql.conf. Alternatively, they can be changed in a PostgreSQL login session via the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf.

Impact:

All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files. A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
The exploit is made in the configuration files. These changes are effected upon server restart. Once detected, the unauthorized/undesired change can be made by editing the altered configuration file and executing a server restart. In the case where the parameter has been set on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:

Query the view pg_settings and compare with previous query outputs for any changes.

Review the configuration files postgreql.conf and postgreql.auto.conf and compare with previously archived file copies for any changes

Examine the process output and look for parameters that were used at server startup:

ps aux | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context = 'superuser' order by 1
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/template1:
  [""allow_in_place_tablespaces"",""off""]
  [""backtrace_functions"",null]
  [""dynamic_library_path"",""$libdir""]
  [""ignore_checksum_failure"",""off""]
  [""jit_dump_bitcode"",""off""]
  [""local_preload_libraries"",null]
  [""lo_compat_privileges"",""off""]
  [""log_parameter_max_length"",""-1""]
  [""max_stack_depth"",""6144""]
  [""rds.extensions"",""address_standardizer, address_standardizer_data_us, amcheck, autoinc, aws_commons, aws_lambda, aws_s3, bloom, bool_plperl, btree_gin, btree_gist, citext, cube, dblink, dict_int, dict_xsyn, earthdistance, flow_control, fuzzystrmatch, h3, h3_postgis, hll, hstore, hstore_plperl, hypopg, insert_username, intagg, intarray, ip4r, isn, jsonb_plperl, lo, log_fdw, ltree, moddatetime, mysql_fdw, oracle_fdw, orafce, pageinspect, pgactive, pgaudit, pgcrypto, pglogical, pgrouting, pgrowlocks, pgstattuple, pgtap, pg_bigm, pg_buffercache, pg_cron, pg_freespacemap, pg_hint_plan, pg_partman, pg_prewarm, pg_proctab, pg_repack, pg_similarity, pg_stat_statements, pg_tle, pg_transport, pg_trgm, pg_visibility, plcoffee, plls, plperl, plpgsql, plprofiler, plrust, pltcl, plv8, postgis, postgis_raster, postgis_tiger_geocoder, postgis_topology, postgres_fdw, prefix, rdkit, rds_tools, refint, seg, sslinfo, tablefunc, tcn, tds_fdw, test_parser, tsm_system_rows, tsm_system_time, unaccent, uuid-ossp, vector""]
  [""rds.superuser_variables"",""session_replication_role""]
  [""session_preload_libraries"",null]
  [""update_process_title"",""on""]
  [""wal_compression"",""on""]
  [""wal_consistency_checking"",null]
  [""wal_init_zero"",""on""]
  [""wal_recycle"",""on""]
  [""zero_damaged_pages"",""off""]","The exploit is made in the configuration files. These changes are effected upon server restart. Once detected, the unauthorized/undesired change can be made by editing the altered configuration file and executing a server restart. In the case where the parameter has been set on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:

Query the view pg_settings and compare with previous query outputs for any changes.

Review the configuration files postgreql.conf and postgreql.auto.conf and compare with previously archived file copies for any changes

Examine the process output and look for parameters that were used at server startup:

ps aux | grep -E -- '[p]ost.*-[D]'

Examine the contents of $PGDATA/postmaster.opts","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.6 Ensure 'User' Runtime Parameters are Configured"" : [WARNING]

These PostgreSQL runtime parameters are managed at the user account (ROLE) level.

Rationale:

In order to improve performance and optimize features, a ROLE has the privilege of setting numerous parameters in a transaction, session, or entity attribute. Any ROLE can alter any of these parameters.

Impact:

A denial of service is possible by the over-allocating of limited resources, such as RAM. Changing VACUUM parameters can force a server shutdown which is standard procedure preventing data corruption from transaction ID wraparound. Data can be corrupted by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Logging can be altered and obfuscated to inhibit root cause analysis.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
In the matter of a user session, the login sessions must be validated that it is not executing undesired parameter changes. In the matter of attributes that have been changed in entities, they must be manually reverted to their default value(s).

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where context = 'user' order by 1
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/template1:
  [""application_name"",null]
  [""array_nulls"",""on""]
  [""backend_flush_after"",""0""]
  [""backslash_quote"",""safe_encoding""]
  [""bytea_output"",""hex""]
  [""check_function_bodies"",""on""]
  [""client_encoding"",""UTF8""]
  [""client_min_messages"",""notice""]
  [""commit_siblings"",""5""]
  [""constraint_exclusion"",""partition""]
  [""cpu_index_tuple_cost"",""0.005""]
  [""cpu_operator_cost"",""0.0025""]
  [""cpu_tuple_cost"",""0.01""]
  [""cursor_tuple_fraction"",""0.1""]
  [""DateStyle"",""ISO, MDY""]
  [""debug_pretty_print"",""on""]
  [""debug_print_parse"",""off""]
  [""debug_print_plan"",""off""]
  [""debug_print_rewritten"",""off""]
  [""default_statistics_target"",""100""]
  [""default_table_access_method"",""heap""]
  [""default_tablespace"",null]
  [""default_text_search_config"",""pg_catalog.simple""]
  [""default_transaction_deferrable"",""off""]
  [""default_transaction_isolation"",""read committed""]
  [""default_transaction_read_only"",""off""]
  [""effective_cache_size"",""994031""]
  [""effective_io_concurrency"",""1""]
  [""enable_bitmapscan"",""on""]
  [""enable_gathermerge"",""on""]
  [""enable_hashagg"",""on""]
  [""enable_hashjoin"",""on""]
  [""enable_incremental_sort"",""on""]
  [""enable_indexonlyscan"",""on""]
  [""enable_indexscan"",""on""]
  [""enable_material"",""on""]
  [""enable_mergejoin"",""on""]
  [""enable_nestloop"",""on""]
  [""enable_parallel_append"",""on""]
  [""enable_parallel_hash"",""on""]
  [""enable_partition_pruning"",""on""]
  [""enable_partitionwise_aggregate"",""off""]
  [""enable_partitionwise_join"",""off""]
  [""enable_seqscan"",""on""]
  [""enable_sort"",""on""]
  [""enable_tidscan"",""on""]
  [""escape_string_warning"",""on""]
  [""exit_on_error"",""off""]
  [""extra_float_digits"",""1""]
  [""force_parallel_mode"",""off""]
  [""from_collapse_limit"",""8""]
  [""geqo"",""on""]
  [""geqo_effort"",""5""]
  [""geqo_generations"",""0""]
  [""geqo_pool_size"",""0""]
  [""geqo_seed"",""0""]
  [""geqo_selection_bias"",""2""]
  [""geqo_threshold"",""12""]
  [""gin_fuzzy_search_limit"",""0""]
  [""gin_pending_list_limit"",""4096""]
  [""hash_mem_multiplier"",""1""]
  [""idle_in_transaction_session_timeout"",""86400000""]
  [""IntervalStyle"",""postgres""]
  [""jit"",""off""]
  [""jit_above_cost"",""100000""]
  [""jit_expressions"",""on""]
  [""jit_inline_above_cost"",""500000""]
  [""jit_optimize_above_cost"",""500000""]
  [""jit_tuple_deforming"",""on""]
  [""join_collapse_limit"",""8""]
  [""lc_monetary"",""C""]
  [""lc_numeric"",""C""]
  [""lc_time"",""C""]
  [""lock_timeout"",""0""]
  [""logical_decoding_work_mem"",""65536""]
  [""log_parameter_max_length_on_error"",""0""]
  [""maintenance_io_concurrency"",""10""]
  [""maintenance_work_mem"",""260729""]
  [""max_parallel_maintenance_workers"",""2""]
  [""max_parallel_workers"",""8""]
  [""max_parallel_workers_per_gather"",""2""]
  [""min_parallel_index_scan_size"",""64""]
  [""min_parallel_table_scan_size"",""1024""]
  [""operator_precedence_warning"",""off""]
  [""parallel_leader_participation"",""on""]
  [""parallel_setup_cost"",""1000""]
  [""parallel_tuple_cost"",""0.1""]
  [""password_encryption"",""scram-sha-256""]
  [""plan_cache_mode"",""auto""]
  [""quote_all_identifiers"",""off""]
  [""random_page_cost"",""4""]
  [""row_security"",""on""]
  [""search_path"",""\""$user\"", public""]
  [""seq_page_cost"",""1""]
  [""standard_conforming_strings"",""on""]
  [""statement_timeout"",""0""]
  [""synchronize_seqscans"",""on""]
  [""synchronous_commit"",""on""]
  [""tcp_keepalives_count"",""2""]
  [""tcp_keepalives_idle"",""300""]
  [""tcp_keepalives_interval"",""30""]
  [""tcp_user_timeout"",""0""]
  [""temp_buffers"",""1024""]
  [""temp_tablespaces"",null]
  [""TimeZone"",""UTC""]
  [""timezone_abbreviations"",""Default""]
  [""trace_notify"",""off""]
  [""trace_sort"",""off""]
  [""transaction_deferrable"",""off""]
  [""transaction_isolation"",""read committed""]
  [""transaction_read_only"",""off""]
  [""transform_null_equals"",""off""]
  [""vacuum_cleanup_index_scale_factor"",""0.1""]
  [""vacuum_cost_delay"",""0""]
  [""vacuum_cost_limit"",""1500""]
  [""vacuum_cost_page_dirty"",""20""]
  [""vacuum_cost_page_hit"",""1""]
  [""vacuum_cost_page_miss"",""5""]
  [""vacuum_freeze_min_age"",""50000000""]
  [""vacuum_freeze_table_age"",""150000000""]
  [""vacuum_multixact_freeze_min_age"",""5000000""]
  [""vacuum_multixact_freeze_table_age"",""150000000""]
  [""wal_sender_timeout"",""30000""]
  [""wal_skip_threshold"",""2048""]
  [""work_mem"",""12288""]
  [""xmlbinary"",""base64""]
  [""xmloption"",""content""]","In the matter of a user session, the login sessions must be validated that it is not executing undesired parameter changes. In the matter of attributes that have been changed in entities, they must be manually reverted to their default value(s).","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.8 Ensure TLS is enabled and configured correctly"" : [PASSED]

TLS on a PostgreSQL server should be enabled and configured to encrypt TCP traffic to and from the server.

Rationale:

If TLS is not enabled and configured correctly, this increases the risk of data being compromised in transit.

Impact:

A self-signed certificate can be used for testing, but a certificate signed by a certificate authority (CA) (either one of the global CAs or a local one) should be used in production so that clients can verify the server's identity. If all the database clients are local to the organization, using a local CA is recommended.

To ultimately enable and enforce TLS authentication for the server, appropriate hostssl records must be added to the pg_hba.conf file. Be sure to reload PostgreSQL after any changes (restart not required).

Note: The hostssl record matches connection attempts made using TCP/IP, but only when the connection is made with TLS encryption. The host record matches attempts made using TCP/IP, but allows both TLS and non-TLS connections. The hostnossl record matches attempts made using TCP/IP, but only those without TLS. Care should be taken to enforce TLS as appropriate.

Solution:
For this example, and ease of illustration, we will be using a self-signed certificate (generated via openssl) for the server, and the PostgreSQL defaults for file naming and location in the PostgreSQL $PGDATA directory.

# whoami
postgres
# # create new certificate and enter details at prompts
# openssl req -new -newkey rsa:4096 -text -out server.req
Generating a 4096 bit RSA private key
.....................+++
..................................................................+++
writing new private key to 'privkey.pem'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:US
State or Province Name (full name) []:Ohio
Locality Name (eg, city) [Default City]:Columbus
Organization Name (eg, company) [Default Company Ltd]:Me Inc
Organizational Unit Name (eg, section) []:IT
Common Name (eg, your name or your server's hostname) []:my.me.inc
Email Address []:me@meinc.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:

# # remove passphrase (required for automatic server start up, if not using 'ssl_passphrase_command')
# openssl rsa -in privkey.pem -out server.key && rm privkey.pem
Enter pass phrase for privkey.pem:
writing RSA key

# # modify certificate to self signed, generate .key and .crt files
# openssl req -x509 -in server.req -text -key server.key -out server.crt

# # copy .key and .crt files to appropriate location, here default $PGDATA
$ cp server.key server.crt $PGDATA

# # restrict file mode for server.key
$ chmod og-rwx server.key

Edit the PostgreSQL configuration file postgresql.conf to ensure the following items are set. Again, we are using defaults. Note that altering these parameters will require restarting the cluster.

# (change requires restart)
ssl = on

# force clients to use TLS v1.3 or newer
ssl_min_protocol_version = 'TLSv1.3'

# (change requires restart)
ssl_cert_file = 'server.crt'

# (change requires restart)
ssl_key_file = 'server.key'

Finally, restart PostgreSQL and confirm ssl using commands outlined in Audit Procedures:

postgres=# show ssl;
 ssl
-----
 on
(1 row)

Default Value:

Note that server.crt and server.key are the default names used by PostgreSQL. These files can be named otherwise, just ensure you update the postgresql.conf to use these new names. The current names can be found via SQL:

postgres=# select name, setting from pg_settings where name like 'ssl%file';

|--------------------|------------|

|        name        |  setting   |

|--------------------|------------|

| ssl_ca_file        |            |

| ssl_cert_file      | server.crt |

| ssl_crl_file       |            |

| ssl_dh_params_file |            |

| ssl_key_file       | server.key |

|--------------------|------------|

(5 rows)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1A,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1

Policy Value:
SQL_POLICY
sql_request: show ssl
sql_expect: STRING - on

Actual Value:
5432/template1:
* [""on""]","For this example, and ease of illustration, we will be using a self-signed certificate (generated via openssl) for the server, and the PostgreSQL defaults for file naming and location in the PostgreSQL $PGDATA directory.

# whoami
postgres
# # create new certificate and enter details at prompts
# openssl req -new -newkey rsa:4096 -text -out server.req
Generating a 4096 bit RSA private key
.....................+++
..................................................................+++
writing new private key to 'privkey.pem'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:US
State or Province Name (full name) []:Ohio
Locality Name (eg, city) [Default City]:Columbus
Organization Name (eg, company) [Default Company Ltd]:Me Inc
Organizational Unit Name (eg, section) []:IT
Common Name (eg, your name or your server's hostname) []:my.me.inc
Email Address []:me@meinc.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:

# # remove passphrase (required for automatic server start up, if not using 'ssl_passphrase_command')
# openssl rsa -in privkey.pem -out server.key && rm privkey.pem
Enter pass phrase for privkey.pem:
writing RSA key

# # modify certificate to self signed, generate .key and .crt files
# openssl req -x509 -in server.req -text -key server.key -out server.crt

# # copy .key and .crt files to appropriate location, here default $PGDATA
$ cp server.key server.crt $PGDATA

# # restrict file mode for server.key
$ chmod og-rwx server.key

Edit the PostgreSQL configuration file postgresql.conf to ensure the following items are set. Again, we are using defaults. Note that altering these parameters will require restarting the cluster.

# (change requires restart)
ssl = on

# force clients to use TLS v1.3 or newer
ssl_min_protocol_version = 'TLSv1.3'

# (change requires restart)
ssl_cert_file = 'server.crt'

# (change requires restart)
ssl_key_file = 'server.key'

Finally, restart PostgreSQL and confirm ssl using commands outlined in Audit Procedures:

postgres=# show ssl;
 ssl
-----
 on
(1 row)

Default Value:

Note that server.crt and server.key are the default names used by PostgreSQL. These files can be named otherwise, just ensure you update the postgresql.conf to use these new names. The current names can be found via SQL:

postgres=# select name, setting from pg_settings where name like 'ssl%file';

|--------------------|------------|

|        name        |  setting   |

|--------------------|------------|

| ssl_ca_file        |            |

| ssl_cert_file      | server.crt |

| ssl_crl_file       |            |

| ssl_dh_params_file |            |

| ssl_key_file       | server.key |

|--------------------|------------|

(5 rows)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""6.9 Ensure the pgcrypto extension is installed and configured correctly"" : [FAILED]

PostgreSQL must implement cryptographic mechanisms to prevent unauthorized disclosure or modification of organization-defined information at rest (to include, at a minimum, PII and classified information) on organization-defined information system components.

Rationale:

PostgreSQL instances handling data that requires 'data at rest' protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to PostgreSQL or implemented via additional software or operating system/file system settings, as appropriate to the situation. Information at rest refers to the state of information when it is located on a secondary storage device (e.g. disk drive, tape drive) within an organizational information system.

The selection of a cryptographic mechanism is based on the need to protect the integrity of organizational information. The strength of the mechanism is commensurate with the security category and/or classification of the information. Organizations have the flexibility to either encrypt all information on storage devices (i.e. full disk encryption) or encrypt specific data structures (e.g. files, records, or fields). Organizations may also optionally choose to implement both to implement layered security.

The decision of whether, and what, to encrypt rests with the data owner and is also influenced by the physical measures taken to secure the equipment and media on which the information resides. Organizations may choose to employ different mechanisms to achieve confidentiality and integrity protection, as appropriate. If the confidentiality and integrity of application data are not protected, the data will be open to compromise and unauthorized modification.

The PostgreSQL pgcrypto extension provides cryptographic functions for PostgreSQL and is intended to address the confidentiality and integrity of user and system information at rest in non-mobile devices.

Impact:

When considering or undertaking any form of encryption, it is critical to understand the state of the encrypted data at all stages of the data lifecycle. The use of pgcrypto ensures that the data at rest in the tables (and therefore on disk) is encrypted, but for the data to be accessed by any users or applications, said users/applications will, by necessity, have access to the encrypt and decrypt keys and the data in question will be encrypted/decrypted in memory and then transferred to/from the user/application in that form.

Solution:
The pgcrypto extension is included with the PostgreSQL 'contrib' package. Although included, it needs to be created in the database.

As the database administrator, run the following:

postgres=# CREATE EXTENSION pgcrypto;
CREATE EXTENSION

Verify pgcrypto is installed:

postgres=# SELECT * FROM pg_available_extensions WHERE name='pgcrypto';
   name   | default_version | installed_version |         comment
----------+-----------------+-------------------+-------------------------
 pgcrypto | 1.3             | 1.3               | cryptographic functions
(1 row)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|1M,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1

Policy Value:
SQL_POLICY
sql_request: SELECT * FROM pg_available_extensions where name='pgcrypto'
sql_expect: STRING - pgcrypto
sql_expect: REGEX - .*
sql_expect: REGEX - .*
sql_expect: REGEX - .*

Actual Value:
5432/template1:
  [""pgcrypto"",""1.3"",null,""cryptographic functions""]","The pgcrypto extension is included with the PostgreSQL 'contrib' package. Although included, it needs to be created in the database.

As the database administrator, run the following:

postgres=# CREATE EXTENSION pgcrypto;
CREATE EXTENSION

Verify pgcrypto is installed:

postgres=# SELECT * FROM pg_available_extensions WHERE name='pgcrypto';
   name   | default_version | installed_version |         comment
----------+-----------------+-------------------+-------------------------
 pgcrypto | 1.3             | 1.3               | cryptographic functions
(1 row)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.1 Ensure a replication-only user is created and used for streaming replication"" : [WARNING]

Create a new user specifically for use by streaming replication instead of using the superuser account.

Rationale:

As it is not necessary to be a superuser to initiate a replication connection, it is proper to create an account specifically for replication. This allows further 'locking down' the uses of the superuser account and follows the general principle of using the least privileges necessary.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
It will be necessary to create a new role for replication purposes:

postgres=# create user replication_user REPLICATION encrypted password 'XXX';
CREATE ROLE
postgres=# select rolname from pg_roles where rolreplication is true;
     rolname
------------------
 postgres
 replication_user
(2 rows)

When using pg_basebackup (or other replication tools) on your standby server, you would use the replication_user (and its password).

Ensure you allow the new user via your pg_hba.conf file:

# note that 'replication' in the 2nd column is required and is a special
# keyword, not a real database
hostssl replication     replication_user    0.0.0.0/0         scram-sha-256

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
SQL_POLICY
sql_request: select rolname from pg_roles where rolreplication is true;
sql_expect: STRING - rolname

Actual Value:
5432/template1:
  [""rdsrepladmin""]
  [""rdsadmin""]","It will be necessary to create a new role for replication purposes:

postgres=# create user replication_user REPLICATION encrypted password 'XXX';
CREATE ROLE
postgres=# select rolname from pg_roles where rolreplication is true;
     rolname
------------------
 postgres
 replication_user
(2 rows)

When using pg_basebackup (or other replication tools) on your standby server, you would use the replication_user (and its password).

Ensure you allow the new user via your pg_hba.conf file:

# note that 'replication' in the 2nd column is required and is a special
# keyword, not a real database
hostssl replication     replication_user    0.0.0.0/0         scram-sha-256","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.2 Ensure logging of replication commands is configured"" : [PASSED]

Enabling the log_replication_commands setting causes each attempted replication from the server to be logged.

Rationale:

A successful replication connection allows for a complete copy of the data stored within the data cluster to be offloaded to another, potentially insecure, host. As such, it is advisable to log all replication commands that are executed in your database cluster to ensure the data is not off-loaded to an unexpected/undesired location.

Solution:
To enable the logging of replication commands, execute the following:

postgres=# ALTER SYSTEM SET log_replication_commands = 'on';
ALTER SYSTEM
postgres=# SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_replication_commands ;
 log_replication_commands
--------------------------
 on
(1 row)

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3

Policy Value:
SQL_POLICY
sql_request: show log_replication_commands;
sql_expect: STRING - off

Actual Value:
5432/template1:
* [""off""]","To enable the logging of replication commands, execute the following:

postgres=# ALTER SYSTEM SET log_replication_commands = 'on';
ALTER SYSTEM
postgres=# SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_replication_commands ;
 log_replication_commands
--------------------------
 on
(1 row)","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.3 Ensure base backups are configured and functional"" : [WARNING]

A 'base backup' is a copy of the PRIMARY host's data cluster ($PGDATA) and is used to create STANDBY hosts and for Point In Time Recovery (PITR) mechanisms. Base backups should be copied across networks in a secure manner using an encrypted transport mechanism. The PostgreSQL CLI pg_basebackup can be used, however, TLS encryption should be enabled on the server as per section 6.8 of this benchmark. The pgBackRest tool detailed in section 8.3 of this benchmark can also be used to create a 'base backup'.

Rationale:

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
Executing base backups using pg_basebackup requires the following steps on the standby server:

$ whoami
postgres
$ pg_basebackup --host=name_or_IP_of_master \
--port=5432 \
--username=replication_user \
--pgdata=~postgres/13/data \
--progress --verbose --write-recovery-conf --wal-method=stream

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.8.9,800-53|CP-4,800-53|CP-9(1),800-53r5|CP-4,800-53r5|CP-9(1),CSCv7|10.3,CSCv8|11.5,CSF|PR.IP-4,CSF|PR.IP-10,GDPR|32.1.b,GDPR|32.1.c,HIPAA|164.306(a)(1),ISO/IEC-27001|A.12.3.1,ITSG-33|CP-4,ITSG-33|CP-9(1),LEVEL|1M,NESA|T2.2.4,NESA|T3.5.1,QCSC-v1|10.2.1,QCSC-v1|11.2

Policy Value:
WARNING

Actual Value:
5432/template1:
WARNING","Executing base backups using pg_basebackup requires the following steps on the standby server:

$ whoami
postgres
$ pg_basebackup --host=name_or_IP_of_master \
--port=5432 \
--username=replication_user \
--pgdata=~postgres/13/data \
--progress --verbose --write-recovery-conf --wal-method=stream","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","PASSED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.4 Ensure WAL archiving is configured and functional - archive_mode"" : [PASSED]

Write Ahead Log (WAL) Archiving, or Log Shipping, is the process of sending transaction log files from the PRIMARY host either to one or more STANDBY hosts or to be archived on a remote storage device for later use, e.g. PITR. There are several utilities that can copy WALs including, but not limited to, cp, scp, sftp, and rynsc. Basically, the server follows a set of runtime parameters which define when the WAL should be copied using one of the aforementioned utilities.

Rationale:

Unless the server has been correctly configured, one runs the risk of sending WALs in an unsecured, unencrypted fashion.

Solution:
Change parameters and restart the server as required.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1A,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where name ~ '^archive' ORDER BY 1;
sql_expect: STRING - archive_mode
sql_expect: STRING - on
match_all: NO

Actual Value:
5432/template1:
  [""archive_cleanup_command"",null]
  [""archive_command"",""/etc/rds/dbbin/pgscripts/rds_wal_archive %p skipTimeCheckForWalSegmentAndReadyFile""]
* [""archive_mode"",""on""]
  [""archive_timeout"",""300""]","Change parameters and restart the server as required.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","FAILED","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.4 Ensure WAL archiving is configured and functional - archive_command"" : [FAILED]

Write Ahead Log (WAL) Archiving, or Log Shipping, is the process of sending transaction log files from the PRIMARY host either to one or more STANDBY hosts or to be archived on a remote storage device for later use, e.g. PITR. There are several utilities that can copy WALs including, but not limited to, cp, scp, sftp, and rynsc. Basically, the server follows a set of runtime parameters which define when the WAL should be copied using one of the aforementioned utilities.

Rationale:

Unless the server has been correctly configured, one runs the risk of sending WALs in an unsecured, unencrypted fashion.

Solution:
Change parameters and restart the server as required.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1A,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where name ~ '^archive' ORDER BY 1;
sql_expect: STRING - archive_command
sql_expect: STRING - \'.*ssh
match_all: NO

Actual Value:
5432/template1:
  [""archive_cleanup_command"",null]
  [""archive_command"",""/etc/rds/dbbin/pgscripts/rds_wal_archive %p skipTimeCheckForWalSegmentAndReadyFile""]
  [""archive_mode"",""on""]
  [""archive_timeout"",""300""]","Change parameters and restart the server as required.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""7.5 Ensure streaming replication parameters are configured correctly"" : [WARNING]

Streaming replication from a PRIMARY host transmits DDL, DML, passwords, and other potentially sensitive activities and data. These connections should be protected with Secure Sockets Layer (SSL).

Rationale:

Unencrypted transmissions could reveal sensitive information to unauthorized parties. Unauthenticated connections could enable man-in-the-middle attacks.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

Solution:
Review prior sections in this benchmark regarding TLS certificates, replication user, and WAL archiving.

Confirm the file $PGDATA/standby.signal is present on the STANDBY host and $PGDATA/postgresql.auto.conf contains lines similar to the following:

primary_conninfo = 'user=replication_user password=mypassword host=mySrcHost port=5432 sslmode=require sslcompression=1'

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1

Policy Value:
WARNING

Actual Value:
5432/template1:
WARNING","Review prior sections in this benchmark regarding TLS certificates, replication user, and WAL archiving.

Confirm the file $PGDATA/standby.signal is present on the STANDBY host and $PGDATA/postgresql.auto.conf contains lines similar to the following:

primary_conninfo = 'user=replication_user password=mypassword host=mySrcHost port=5432 sslmode=require sslcompression=1'","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""8.1 Ensure PostgreSQL subdirectory locations are outside the data cluster"" : [WARNING]

The PostgreSQL cluster is organized to carry out specific tasks in subdirectories. For the purposes of performance, reliability, and security some of these subdirectories should be relocated outside the data cluster.

Rationale:

Some subdirectories contain information, such as logs, which can be of value to others such as developers. Other subdirectories can gain a performance benefit when placed on fast storage devices. Other subdirectories contain temporary files created and used during processing. Finally, relocating a subdirectory to a separate and distinct partition mitigates denial of service and involuntary server shutdown when excessive writes fill the data cluster's partition, e.g. pg_wal, pg_log, and temp_tablespaces.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Perform the following steps to remediate the subdirectory locations and permissions:

Determine appropriate data, log, and tablespace directories and locations based on your organization's security policies. If necessary, relocate all listed directories outside the data cluster.

If not relocating temp_tablespaces, the temp_file_limit parameter must be changed from its default value.

Ensure file permissions are restricted as much as possible, i.e. only superuser read access.

When directories are relocated to other partitions, ensure that they are of sufficient size to mitigate against excessive space utilization.

Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.

To relocate temp_tablespaces to an existing mount point outside the data cluster is accomplished by:

postgres=# CREATE TABLESPACE temp_tablespc LOCATION '/path/to/existing/desired/mount/point';
postgres=# ALTER SYSTEM SET temp_tablespaces = 'temp_tablespc';
postgres=# SELECT pg_reload_conf();

Default Value:

The default for data_directory is ConfigDir and the default for log_directory is log (based on the absolute path of data_directory). The defaults for tablespace settings are null, or not set, upon cluster creation.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: select name, setting from pg_settings where (name ~ '_directory$' or name ~ '_tablespace')
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/template1:
  [""allow_in_place_tablespaces"",""off""]
  [""data_directory"",""/rdsdbdata/db""]
  [""default_tablespace"",null]
  [""log_directory"",""/rdsdbdata/log/error""]
  [""rds.temp_tablespaces"",""rds_temp_tablespace""]
  [""stats_temp_directory"",""/rdsdbdata/db/pg_stat_tmp""]
  [""temp_tablespaces"",null]","Perform the following steps to remediate the subdirectory locations and permissions:

Determine appropriate data, log, and tablespace directories and locations based on your organization's security policies. If necessary, relocate all listed directories outside the data cluster.

If not relocating temp_tablespaces, the temp_file_limit parameter must be changed from its default value.

Ensure file permissions are restricted as much as possible, i.e. only superuser read access.

When directories are relocated to other partitions, ensure that they are of sufficient size to mitigate against excessive space utilization.

Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.

To relocate temp_tablespaces to an existing mount point outside the data cluster is accomplished by:

postgres=# CREATE TABLESPACE temp_tablespc LOCATION '/path/to/existing/desired/mount/point';
postgres=# ALTER SYSTEM SET temp_tablespaces = 'temp_tablespc';
postgres=# SELECT pg_reload_conf();

Default Value:

The default for data_directory is ConfigDir and the default for log_directory is log (based on the absolute path of data_directory). The defaults for tablespace settings are null, or not set, upon cluster creation.","https://workbench.cisecurity.org/benchmarks/11864",""
"148944","","","WARNING","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","0","PostgreSQL DB Compliance Checks","Compliance checks for PostgreSQL DB devices.","""8.3 Ensure miscellaneous configuration settings are correct"" : [WARNING]

This recommendation covers non-regular, special files, and dynamic libraries.

PostgreSQL permits local logins via the UNIX DOMAIN SOCKET and, for the most part, anyone with a legitimate Unix login account can make the attempt. Limiting PostgreSQL login attempts can be made by relocating the UNIX DOMAIN SOCKET to a subdirectory with restricted permissions.

The creation and implementation of user-defined dynamic libraries is an extraordinary powerful capability. In the hands of an experienced DBA/programmer, it can significantly enhance the power and flexibility of the RDBMS; but new and unexpected behavior can also be assigned to the RDBMS, resulting in a very dangerous environment in what should otherwise be trusted.

Rationale:

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.

Solution:
Follow these steps to remediate the configuration:

Determine permissions based on your organization's security policies.

Relocate all files and ensure their permissions are restricted as much as possible, i.e. only superuser read access.

Ensure all directories where these files are located have restricted permissions such that the superuser can read but not write.

Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.

Default Value:

The dynamic_library_path default is $libdir and unix_socket_directories default is /var/run/postgresql, /tmp. The default for external_pid_file and all library parameters are initially null, or not set, upon cluster creation.

See Also: https://workbench.cisecurity.org/benchmarks/11864

Reference: 800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3

Policy Value:
SQL_POLICY
sql_request: SELECT name, setting FROM pg_settings WHERE name IN ('external_pid_file' ,'unix_socket_directories' ,'shared_preload_libraries' ,'dynamic_library_path' ,'local_preload_libraries' ,'session_preload_libraries' )
sql_expect: NULL - NULL
sql_expect: NULL - NULL

Actual Value:
5432/template1:
  [""dynamic_library_path"",""$libdir""]
  [""external_pid_file"",null]
  [""local_preload_libraries"",null]
  [""session_preload_libraries"",null]
  [""shared_preload_libraries"",""rdsutils,pg_stat_statements""]
  [""unix_socket_directories"",""/tmp""]","Follow these steps to remediate the configuration:

Determine permissions based on your organization's security policies.

Relocate all files and ensure their permissions are restricted as much as possible, i.e. only superuser read access.

Ensure all directories where these files are located have restricted permissions such that the superuser can read but not write.

Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.

Default Value:

The dynamic_library_path default is $libdir and unix_socket_directories default is /var/run/postgresql, /tmp. The default for external_pid_file and all library parameters are initially null, or not set, upon cluster creation.","https://workbench.cisecurity.org/benchmarks/11864",""
"156899","","","None","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","SSL/TLS Recommended Cipher Suites","The remote host advertises discouraged SSL/TLS ciphers.","The remote host has open SSL/TLS ports which advertise discouraged cipher suites. It is recommended to only enable
support for the following cipher suites:

TLSv1.3:
  - 0x13,0x01 TLS13_AES_128_GCM_SHA256
  - 0x13,0x02 TLS13_AES_256_GCM_SHA384
  - 0x13,0x03 TLS13_CHACHA20_POLY1305_SHA256

TLSv1.2:
  - 0xC0,0x2B ECDHE-ECDSA-AES128-GCM-SHA256
  - 0xC0,0x2F ECDHE-RSA-AES128-GCM-SHA256
  - 0xC0,0x2C ECDHE-ECDSA-AES256-GCM-SHA384
  - 0xC0,0x30 ECDHE-RSA-AES256-GCM-SHA384
  - 0xCC,0xA9 ECDHE-ECDSA-CHACHA20-POLY1305
  - 0xCC,0xA8 ECDHE-RSA-CHACHA20-POLY1305

This is the recommended configuration for the vast majority of services, as it is highly secure and compatible with
nearly every client released in the last five (or more) years.","Only enable support for recommened cipher suites.","https://wiki.mozilla.org/Security/Server_Side_TLS
https://ssl-config.mozilla.org/","The remote host has listening SSL/TLS ports which advertise the discouraged cipher suites outlined below:


  High Strength Ciphers (>= 112-bit key)

    Name                          Code             KEX           Auth     Encryption             MAC
    ----------------------        ----------       ---           ----     ---------------------  ---
    DHE-RSA-AES128-SHA256         0x00, 0x9E       DH            RSA      AES-GCM(128)           SHA256
    DHE-RSA-AES256-SHA384         0x00, 0x9F       DH            RSA      AES-GCM(256)           SHA384
    RSA-AES128-SHA256             0x00, 0x9C       RSA           RSA      AES-GCM(128)           SHA256
    RSA-AES256-SHA384             0x00, 0x9D       RSA           RSA      AES-GCM(256)           SHA384
    DHE-RSA-AES128-SHA            0x00, 0x33       DH            RSA      AES-CBC(128)           SHA1
    DHE-RSA-AES256-SHA            0x00, 0x39       DH            RSA      AES-CBC(256)           SHA1
    DHE-RSA-CAMELLIA128-SHA       0x00, 0x45       DH            RSA      Camellia-CBC(128)      SHA1
    DHE-RSA-CAMELLIA256-SHA       0x00, 0x88       DH            RSA      Camellia-CBC(256)      SHA1
    ECDHE-RSA-AES128-SHA          0xC0, 0x13       ECDH          RSA      AES-CBC(128)           SHA1
    ECDHE-RSA-AES256-SHA          0xC0, 0x14       ECDH          RSA      AES-CBC(256)           SHA1
    AES128-SHA                    0x00, 0x2F       RSA           RSA      AES-CBC(128)           SHA1
    AES256-SHA                    0x00, 0x35       RSA           RSA      AES-CBC(256)           SHA1
    CAMELLIA128-SHA               0x00, 0x41       RSA           RSA      Camellia-CBC(128)      SHA1
    CAMELLIA256-SHA               0x00, 0x84       RSA           RSA      Camellia-CBC(256)      SHA1
    DHE-RSA-AES128-SHA256         0x00, 0x67       DH            RSA      AES-CBC(128)           SHA256
    DHE-RSA-AES256-SHA256         0x00, 0x6B       DH            RSA      AES-CBC(256)           SHA256
    ECDHE-RSA-AES128-SHA256       0xC0, 0x27       ECDH          RSA      AES-CBC(128)           SHA256
    ECDHE-RSA-AES256-SHA384       0xC0, 0x28       ECDH          RSA      AES-CBC(256)           SHA384
    RSA-AES128-SHA256             0x00, 0x3C       RSA           RSA      AES-CBC(128)           SHA256
    RSA-AES256-SHA256             0x00, 0x3D       RSA           RSA      AES-CBC(256)           SHA256

The fields above are :

  {Tenable ciphername}
  {Cipher ID code}
  Kex={key exchange}
  Auth={authentication}
  Encrypt={symmetric encryption method}
  MAC={message authentication code}
  {export flag}
"
"179922","CVE-2023-39417","9.0","High","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL 11.x < 11.21 / 12.x < 12.16 / 13.x < 13.12 / 14.x < 14.9 / 15.x < 15.4 Multiple Vulnerabilities","The remote database server is affected by multiple vulnerabilities","The version of PostgreSQL installed on the remote host is 11 prior to 11.21, 12 prior to 12.16, 13 prior to 13.12, 14
prior to 14.9, or 15 prior to 15.4. As such, it is potentially affected by a vulnerability :

  - An extension script is vulnerable if it uses @extowner@, @extschema@, or @extschema:...@ inside a quoting
    construct (dollar quoting, '', or ). No bundled extension is vulnerable. Vulnerable uses do appear in a
    documentation example and in non-bundled extensions. Hence, the attack prerequisite is an administrator having
    installed files of a vulnerable, trusted, non-bundled extension. Subject to that prerequisite, this enables an
    attacker having database-level CREATE privilege to execute arbitrary code as the bootstrap superuser. PostgreSQL
    will block this attack in the core server, so there's no need to modify individual extensions. (CVE-2023-39417)

  - A vulnerability was found in PostgreSQL with the use of the MERGE command, which fails to test new rows against row
    security policies defined for UPDATE and SELECT. If UPDATE and SELECT policies forbid some rows that INSERT policies
    do not forbid, a user could store such rows. (CVE-2023-39418)

Note that Nessus has not tested for these issues but has instead relied only on the application's self-reported version
number.","Upgrade to PostgreSQL 11.21 / 12.16 / 13.12 / 14.9 / 15.4 or later","http://www.nessus.org/u?88535bbe","
  Installed version : 13.11
  Fixed version     : 13.12
"
"179922","CVE-2023-39418","9.0","High","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL 11.x < 11.21 / 12.x < 12.16 / 13.x < 13.12 / 14.x < 14.9 / 15.x < 15.4 Multiple Vulnerabilities","The remote database server is affected by multiple vulnerabilities","The version of PostgreSQL installed on the remote host is 11 prior to 11.21, 12 prior to 12.16, 13 prior to 13.12, 14
prior to 14.9, or 15 prior to 15.4. As such, it is potentially affected by a vulnerability :

  - An extension script is vulnerable if it uses @extowner@, @extschema@, or @extschema:...@ inside a quoting
    construct (dollar quoting, '', or ). No bundled extension is vulnerable. Vulnerable uses do appear in a
    documentation example and in non-bundled extensions. Hence, the attack prerequisite is an administrator having
    installed files of a vulnerable, trusted, non-bundled extension. Subject to that prerequisite, this enables an
    attacker having database-level CREATE privilege to execute arbitrary code as the bootstrap superuser. PostgreSQL
    will block this attack in the core server, so there's no need to modify individual extensions. (CVE-2023-39417)

  - A vulnerability was found in PostgreSQL with the use of the MERGE command, which fails to test new rows against row
    security policies defined for UPDATE and SELECT. If UPDATE and SELECT policies forbid some rows that INSERT policies
    do not forbid, a user could store such rows. (CVE-2023-39418)

Note that Nessus has not tested for these issues but has instead relied only on the application's self-reported version
number.","Upgrade to PostgreSQL 11.21 / 12.16 / 13.12 / 14.9 / 15.4 or later","http://www.nessus.org/u?88535bbe","
  Installed version : 13.11
  Fixed version     : 13.12
"
"185732","CVE-2023-5868","9.0","High","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL 11.x < 11.22 / 12.x < 12.17 / 13.x < 13.13 / 14.x < 14.10 / 15.x < 15.5 / 16.x < 16.1 Multiple Vulnerabilities","The remote database server is affected by multiple vulnerabilities","The version of PostgreSQL installed on the remote host is 11 prior to 11.22, 12 prior to 12.17, 13 prior to 13.13,
14 prior to 14.10, 15 prior to 15.5, or 16 prior to 16.1. As such, it is potentially affected by multiple
vulnerabilities:

  - Missing overflow checks let authenticated database users write arbitrary bytes to an area of memory that
    facilitates arbitrary code execution and read a wide area of server memory. (CVE-2023-5869)

  - Certain aggregate function calls receiving an 'unknown'-type arguments can disclose bytes of server memory
    up to the next zero byte. (CVE-2023-5868)

  - Role pg_cancel_backend can signal certain superuser processes contrary to the function documentation.
    Examples of processes that could be improperly signaled are the logical replication launcher and the
    autovacuum launcher and workers. (CVE-2023-5870)

Note that Nessus has not tested for these issues but has instead relied only on the application's self-reported version
number.","Upgrade to PostgreSQL 11.22 / 12.17 / 13.13 / 14.10 / 15.5 / 16.1 or later","http://www.nessus.org/u?c84fe996","
  Installed version : 13.11
  Fixed version     : 13.13
"
"185732","CVE-2023-5869","9.0","High","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL 11.x < 11.22 / 12.x < 12.17 / 13.x < 13.13 / 14.x < 14.10 / 15.x < 15.5 / 16.x < 16.1 Multiple Vulnerabilities","The remote database server is affected by multiple vulnerabilities","The version of PostgreSQL installed on the remote host is 11 prior to 11.22, 12 prior to 12.17, 13 prior to 13.13,
14 prior to 14.10, 15 prior to 15.5, or 16 prior to 16.1. As such, it is potentially affected by multiple
vulnerabilities:

  - Missing overflow checks let authenticated database users write arbitrary bytes to an area of memory that
    facilitates arbitrary code execution and read a wide area of server memory. (CVE-2023-5869)

  - Certain aggregate function calls receiving an 'unknown'-type arguments can disclose bytes of server memory
    up to the next zero byte. (CVE-2023-5868)

  - Role pg_cancel_backend can signal certain superuser processes contrary to the function documentation.
    Examples of processes that could be improperly signaled are the logical replication launcher and the
    autovacuum launcher and workers. (CVE-2023-5870)

Note that Nessus has not tested for these issues but has instead relied only on the application's self-reported version
number.","Upgrade to PostgreSQL 11.22 / 12.17 / 13.13 / 14.10 / 15.5 / 16.1 or later","http://www.nessus.org/u?c84fe996","
  Installed version : 13.11
  Fixed version     : 13.13
"
"185732","CVE-2023-5870","9.0","High","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL 11.x < 11.22 / 12.x < 12.17 / 13.x < 13.13 / 14.x < 14.10 / 15.x < 15.5 / 16.x < 16.1 Multiple Vulnerabilities","The remote database server is affected by multiple vulnerabilities","The version of PostgreSQL installed on the remote host is 11 prior to 11.22, 12 prior to 12.17, 13 prior to 13.13,
14 prior to 14.10, 15 prior to 15.5, or 16 prior to 16.1. As such, it is potentially affected by multiple
vulnerabilities:

  - Missing overflow checks let authenticated database users write arbitrary bytes to an area of memory that
    facilitates arbitrary code execution and read a wide area of server memory. (CVE-2023-5869)

  - Certain aggregate function calls receiving an 'unknown'-type arguments can disclose bytes of server memory
    up to the next zero byte. (CVE-2023-5868)

  - Role pg_cancel_backend can signal certain superuser processes contrary to the function documentation.
    Examples of processes that could be improperly signaled are the logical replication launcher and the
    autovacuum launcher and workers. (CVE-2023-5870)

Note that Nessus has not tested for these issues but has instead relied only on the application's self-reported version
number.","Upgrade to PostgreSQL 11.22 / 12.17 / 13.13 / 14.10 / 15.5 / 16.1 or later","http://www.nessus.org/u?c84fe996","
  Installed version : 13.11
  Fixed version     : 13.13
"
"190512","CVE-2024-0985","9.0","High","apd-luigi-prod-fedm-east-luigi-dedicated-rds.ctg7hqh2vrv9.us-east-1.rds.amazonaws.com","tcp","5432","PostgreSQL 12.x < 12.18 / 13.x < 13.14 / 14.x < 14.11 / 15.x < 15.6 SQL Injection","The remote database server is affected by an SQL injection vulnerability.","The version of PostgreSQL installed on the remote host is 12 prior to 12.18, 13 prior to 13.14, 14 prior to 14.11, or 15
prior to 15.6. It is, therefore, affected by following vulnerability:

  - Late privilege drop in REFRESH MATERIALIZED VIEW CONCURRENTLY in PostgreSQL allows an object creator to
    execute arbitrary SQL functions as the command issuer. The command intends to run SQL functions as the
    owner of the materialized view, enabling safe refresh of untrusted materialized views. The victim is a
    superuser or member of one of the attacker's roles. The attack requires luring the victim into running
    REFRESH MATERIALIZED VIEW CONCURRENTLY on the attacker's materialized view. As part of exploiting this
    vulnerability, the attacker creates functions that use CREATE RULE to convert the internally-built
    temporary table to a view. Versions before PostgreSQL 15.6, 14.11, 13.14, and 12.18 are affected. The only
    known exploit does not work in PostgreSQL 16 and later. For defense in depth, PostgreSQL 16.2 adds the
    protections that older branches are using to fix their vulnerability. (CVE-2024-0985)

Note that Nessus has not tested for this issue but has instead relied only on the application's self-reported version
number.","Upgrade to PostgreSQL 12.18 / 13.14 / 14.11 / 15.6 or later","http://www.nessus.org/u?64212796","
  Database name     : template1
  Version source    : PostgreSQL 13.11 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 7.3.1 20180712 (Red Hat 7.3.1-12), 64-bit
  Installed version : 13.11
  Fixed version     : 13.14
"
